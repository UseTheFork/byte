{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Byte","text":"<p>A human-in-the-loop AI coding agent that keeps you in control.</p>"},{"location":"#what-is-byte","title":"What is Byte?","text":"<p>Byte is a CLI coding agent designed for developers who want AI assistance without sacrificing control. Unlike autonomous agents that make multiple decisions and tool calls independently, Byte requires your approval for every decision.</p> <p>Key Features:</p> <ul> <li>Review and confirm every change before it's applied</li> <li>See exactly what the agent modifies in your code</li> <li>Manage precisely what information the AI receives</li> <li>Slots into your existing development environment</li> <li>Structured prompts that adapt and evolve with each interaction</li> <li>Automatic linting, formatting, and testing without extra commands</li> </ul>"},{"location":"#design-philosophy","title":"Design Philosophy","text":"<p>Transparency First - You see the complete prompt, not just your input. All interactions are logged for reference and debugging.</p> <p>Explicit Over Implicit - Changes require approval. Context additions need confirmation. No surprises.</p> <p>Complementary, Not Replacement - Byte enhances your workflow without replacing your tools or editor.</p> <p>Quality Over Quantity - Better prompts produce better results. Byte prioritizes well-structured instructions over large context windows.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Get started in three steps:</p> <pre><code># Install with uv\n$ uv tool install byte\n\n# Navigate to your project\n$ cd /path/to/your/project\n\n# Run Byte\n$ byte\n</code></pre> <p>See the Installation Guide for other installation methods including pip and Nix.</p>"},{"location":"#why-this-approach","title":"Why This Approach?","text":""},{"location":"#human-in-the-loop-design","title":"Human-in-the-Loop Design","text":"<p>Every decision and code change requires your confirmation. If you prefer agents that work autonomously, Byte isn't for you. If you value control and transparency, you'll appreciate the deliberate confirmation flow.</p>"},{"location":"#built-for-experienced-developers","title":"Built for Experienced Developers","text":"<p>Designed for experienced developers who understand good design principles. This isn't a tool where you provide a specification and it builds the entire feature. Instead, Byte excels at small, incremental changes that keep you in control. Understanding when to refactor, how to structure code, and what constitutes good design remains your responsibility.</p>"},{"location":"#searchreplace-over-tools","title":"Search/Replace Over Tools","text":"<p>Instead of giving the AI arbitrary tools, explicit Search/Replace blocks show you the exact changes before they happen, making it easy to cancel or modify the proposed work.</p>"},{"location":"#workflow-preservation","title":"Workflow Preservation","text":"<p>Your editor stays central to development. Whether you use Vim, VS Code, or Jetbrains, Byte complements your existing workflow as something you invoke when needed.</p>"},{"location":"#context-management","title":"Context Management","text":"<p>You control exactly what context the LLM receives:</p> <ul> <li>Add or remove files from the active context</li> <li>Monitor token usage and memory consumption</li> <li>Prevent context overflow with targeted information</li> </ul>"},{"location":"#intelligent-prompting","title":"Intelligent Prompting","text":"<p>Structured prompts adapt with each turn:</p> <ul> <li>Previous Search/Replace blocks get removed to maintain focus</li> <li>Instructions follow clear markdown formatting</li> <li>Reduces \"tunnel vision\" where agents fixate on minor issues</li> <li>Full prompt visibility through logging for debugging</li> </ul>"},{"location":"#integrated-tooling","title":"Integrated Tooling","text":"<p>Linting, formatting, and testing run automatically after code changes are applied. Configure your tools once and they work seamlessly in the background without requiring agent interaction.</p>"},{"location":"#built-with","title":"Built With","text":"<p>Byte leverages modern Python tooling and AI frameworks:</p> <ul> <li>uv - Fast Python package management</li> <li>LangChain - AI framework for language models</li> <li>LangGraph - Graph-based agent workflows</li> <li>Rich - Beautiful terminal output</li> <li>Prompt Toolkit - Interactive command-line interfaces</li> <li>pydoll - Browser automation and control</li> <li>Catppuccin - Soothing pastel theme</li> </ul>"},{"location":"#inspiration","title":"Inspiration","text":"<p>Byte draws inspiration from excellent projects in the coding agent space:</p> <ul> <li>Aider - The pioneering CLI coding agent that proved the concept</li> <li>Charm's Crush - Elegant terminal agent</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to try Byte? Follow these guides:</p> <ul> <li>Installation - Set up Byte on your system</li> <li>Getting Started - Configure and run your first session</li> <li>Settings - Customize Byte's behavior</li> </ul>"},{"location":"concepts/","title":"Concepts","text":"<p>Byte's design revolves around key principles that work together to provide a powerful yet safe environment for AI-assisted development:</p> <ul> <li>Memory &amp; Context Management - Understanding token usage, context limits, and session management</li> <li>File Context - Control which files the AI can see and modify</li> <li>File Watching - Automatic detection of external file changes</li> <li>Conventions - Project-specific coding standards and style guides</li> <li>Linting - Automated code quality checks and fixes</li> <li>Commit - AI-powered commit message generation</li> <li>Web - Scrape webpages and convert to markdown for LLM context</li> <li>Presets - Save and load predefined configurations of files, conventions, and prompts</li> </ul> <p>Read on to explore these concepts in depth, or jump ahead to:</p> <ul> <li>Use the reference documentation to configure Byte for your project</li> </ul>"},{"location":"concepts/commit/","title":"Commit","text":"<p>Byte's commit system uses AI to generate meaningful commit messages by analyzing your staged changes. It automates the entire commit workflow - staging files, running linters, generating commit messages, and handling git operations.</p> <p></p>"},{"location":"concepts/commit/#quick-start","title":"Quick Start","text":"<p>Create a commit:</p> <pre><code>&gt; /commit\n</code></pre> <p>Byte will:</p> <ol> <li>Stage all changed files (with confirmation)</li> <li>Run configured linters on changed files</li> <li>Prompt you to choose between Commit Plan or Single Commit</li> <li>Analyze the git diff with AI</li> <li>Generate commit message(s) based on your choice</li> <li>Create the commit(s)</li> </ol>"},{"location":"concepts/commit/#commit-types","title":"Commit Types","text":"<p>Byte offers two approaches to organizing your commits:</p>"},{"location":"concepts/commit/#commit-plan","title":"Commit Plan","text":"<p>Analyzes your staged changes and intelligently groups related files into multiple logical commits. The Agent:</p> <ul> <li>Reviews all staged files and their diffs</li> <li>Groups related changes together (e.g., feature additions, bug fixes, refactoring)</li> <li>Generates a separate commit message for each group</li> <li>Creates multiple commits automatically</li> </ul> <p>When to use:</p> <ul> <li>Large changesets with multiple logical changes</li> <li>Mixed feature work and bug fixes</li> <li>Changes spanning multiple domains or modules</li> </ul>"},{"location":"concepts/commit/#single-commit","title":"Single Commit","text":"<p>Creates one commit for all staged changes with a single descriptive message. The AI:</p> <ul> <li>Reviews all staged files and their diffs</li> <li>Generates one comprehensive commit message</li> <li>Creates a single commit</li> </ul> <p>When to use:</p> <ul> <li>Focused changes to a single feature or fix</li> <li>Small, cohesive changesets</li> <li>When you want manual control over commit boundaries</li> </ul>"},{"location":"concepts/commit/#error-handling","title":"Error Handling","text":"<p>If a commit fails (for example, when pre-commit hooks modify files), Byte will:</p> <ul> <li>Display the error message</li> <li>Prompt you to stage the changes and try again</li> <li>Re-stage all changes if you confirm</li> <li>Retry the commit with the same message</li> </ul> <p>This is common with pre-commit hooks that automatically format or modify files - the hooks run, change the files, and cause the commit to fail because the staging area no longer matches the working directory.</p>"},{"location":"concepts/commit/#configuration","title":"Configuration","text":""},{"location":"concepts/commit/#linting-integration","title":"Linting Integration","text":"<p>Control linting behavior via <code>.byte/config.yaml</code>:</p> <pre><code>lint:\n  enable: true # Disable to skip linting during commits\n  commands:\n    - command: \"ruff format\"\n      extensions: [\".py\"]\n</code></pre> <p>See Linting concept for detailed configuration.</p>"},{"location":"concepts/commit/#commit-message-format","title":"Commit Message Format","text":"<p>The AI generates messages following conventional commit conventions for both commit types:</p>"},{"location":"concepts/commit/#structure","title":"Structure","text":"<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\n&lt;body&gt;\n\n&lt;footer&gt;\n</code></pre>"},{"location":"concepts/commit/#types","title":"Types","text":"<p>Common commit types the AI uses:</p> <ul> <li>feat - New feature</li> <li>fix - Bug fix</li> <li>docs - Documentation changes</li> <li>style - Code style changes (formatting, whitespace)</li> <li>refactor - Code restructuring without behavior change</li> <li>perf - Performance improvements</li> <li>test - Test additions or modifications</li> <li>chore - Build process, tooling, dependencies</li> </ul>"},{"location":"concepts/commit/#examples","title":"Examples","text":"<p>Simple feature:</p> <pre><code>feat: add password reset functionality\n</code></pre> <p>Bug fix with scope:</p> <pre><code>fix(auth): prevent token expiration race condition\n</code></pre> <p>Breaking change:</p> <pre><code>feat!: redesign authentication API\n\nBREAKING CHANGE: AuthService.login() now returns a Promise\ninstead of synchronous result. Update all callers to use await.\n</code></pre>"},{"location":"concepts/conventions/","title":"Conventions","text":"<p>Conventions are Markdown files stored in <code>.byte/conventions/</code> that describe how code should be written in your project. The AI automatically receives these conventions before generating any code, ensuring consistency across all suggestions and modifications.</p> <p></p>"},{"location":"concepts/conventions/#creating-conventions","title":"Creating Conventions","text":""},{"location":"concepts/conventions/#using-the-convention-command","title":"Using the Convention Command","text":"<p>Byte can automatically generate convention documents by analyzing your codebase:</p> <pre><code>&gt; /convention\n</code></pre> <p>The command will:</p> <ol> <li>Prompt you to select a convention type (style guide, architecture, etc.)</li> <li>Analyze your codebase to extract relevant patterns</li> <li>Generate a focused convention document</li> <li>Save it to <code>.byte/conventions/</code></li> <li>Load it into the current session</li> </ol> <p>Available convention types include:</p> <ul> <li>Language Style Guide - Naming, formatting, type hints, imports</li> <li>Project Architecture - Directory structure, module organization, design patterns</li> <li>Comment Standards - Docstring format, inline comments, documentation practices</li> <li>Code Patterns - Design patterns, error handling, async/await usage</li> <li>Project Tooling - Build systems, package managers, dev tools</li> <li>Documentation - Documentation structure, writing style, examples</li> <li>Frontend Code Patterns - Component structure, state management, UI patterns</li> <li>Backend Code Patterns - API design, database access, service layer organization</li> <li>Other - Custom convention with your own focus</li> </ul>"},{"location":"concepts/conventions/#manual-convention-files","title":"Manual Convention Files","text":"<p>You can also manually create convention documents as Markdown files in <code>.byte/conventions/</code>:</p>"},{"location":"concepts/conventions/#file-format","title":"File Format","text":"<p>Conventions use standard Markdown formatting:</p> <pre><code># Python Style Guide\n\n## General Rules\n\n- Use snake_case for functions and variables\n- Use PascalCase for class names\n- Maximum line length: 88 characters\n\n## Documentation\n\nAll public functions require docstrings with usage examples.\n</code></pre>"},{"location":"concepts/conventions/#how-conventions-work","title":"How Conventions Work","text":""},{"location":"concepts/conventions/#automatic-loading","title":"Automatic Loading","text":"<p>When Byte starts or when you generate a new convention, it:</p> <ol> <li>Scans <code>.byte/conventions/</code> for all <code>.md</code> files</li> <li>Loads each file's content</li> <li>Formats them with metadata (filename and source path)</li> <li>Stores them in memory for quick access</li> </ol> <p>Newly generated conventions are immediately available in the current session without restarting Byte.</p>"},{"location":"concepts/conventions/#best-practices","title":"Best Practices","text":""},{"location":"concepts/conventions/#be-specific","title":"Be Specific","text":"<p>Provide concrete examples rather than abstract rules:</p> <p>Less effective:</p> <pre><code>Use good naming conventions.\n</code></pre> <p>More effective:</p> <pre><code>Use descriptive names:\n\n- `user_repository` not `ur`\n- `calculate_total_price()` not `calc()`\n</code></pre>"},{"location":"concepts/conventions/#show-code-examples","title":"Show Code Examples","text":"<p>Include actual code snippets demonstrating the pattern:</p> <pre><code>## Error Handling\n\nCatch specific exceptions:\n\n\\`\\`\\`python\ntry:\nresult = await process_file(path)\nexcept FileNotFoundError:\nlogger.error(f\"File not found: {path}\")\nreturn None\n\\`\\`\\`\n</code></pre>"},{"location":"concepts/conventions/#keep-it-current","title":"Keep It Current","text":"<p>Update conventions as your project evolves. Remove outdated rules and add new patterns as you discover them.</p>"},{"location":"concepts/conventions/#organize-by-topic","title":"Organize by Topic","text":"<p>Create separate files for different aspects:</p> <ul> <li><code>PYTHON_STYLE.MD</code> - Language-specific formatting</li> <li><code>ARCHITECTURE.MD</code> - System design patterns</li> <li><code>API_DESIGN.MD</code> - API conventions</li> <li><code>TESTING.MD</code> - Test organization and patterns</li> </ul>"},{"location":"concepts/file-context/","title":"File Context","text":"<p>The file context acts as the AI's \"workspace\" - only files added to the context are visible to the AI. This design gives you precise control over what the AI can access and change, preventing unwanted modifications and reducing noise in the AI's decision-making.</p> <p></p>"},{"location":"concepts/file-context/#file-modes","title":"File Modes","text":"<p>Byte supports two access modes for files in context:</p>"},{"location":"concepts/file-context/#read-only-mode","title":"Read-Only Mode","text":"<p>Files added as read-only are visible to the AI for reference but cannot be modified. The main use case is to add files you want the AI to be aware of but not change.</p> <p>Command: <code>/read-only &lt;file_path&gt;</code></p> <pre><code>&gt; /read-only config.yaml\nAdded config.yaml (read-only)\n</code></pre>"},{"location":"concepts/file-context/#editable-mode","title":"Editable Mode","text":"<p>Files added as editable can be modified by the AI through SEARCH/REPLACE blocks.</p> <p>Command: <code>/add &lt;file_path&gt;</code></p> <pre><code>&gt; /add src/main.py\nAdded src/main.py (editable)\n</code></pre>"},{"location":"concepts/file-context/#adding-files","title":"Adding Files","text":""},{"location":"concepts/file-context/#single-files","title":"Single Files","text":"<p>Add individual files by specifying their path relative to the project root:</p> <pre><code>&gt; /add src/services/auth.py\n&gt; /read-only README.md\n</code></pre>"},{"location":"concepts/file-context/#multiple-files-with-wildcards","title":"Multiple Files with Wildcards","text":"<p>Use glob patterns to add multiple files at once:</p> <pre><code>&gt; /add src/models/*.py\nAdded src/models/user.py (editable)\nAdded src/models/post.py (editable)\nAdded src/models/comment.py (editable)\n</code></pre> <p>Supported patterns:</p> <ul> <li><code>*</code> - matches any characters in a filename</li> <li><code>**</code> - matches directories recursively</li> <li><code>?</code> - matches a single character</li> <li><code>[seq]</code> - matches any character in seq</li> </ul> <p>Examples:</p> <pre><code>&gt; /add tests/**/*.py           # All Python test files\n&gt; /add src/domain/*/config.py  # All config.py in domain subdirectories\n&gt; /read-only docs/*.md          # All Markdown files in docs\n</code></pre>"},{"location":"concepts/file-context/#viewing-context","title":"Viewing Context","text":""},{"location":"concepts/file-context/#list-all-files","title":"List All Files","text":"<p>See all files currently in context:</p> <pre><code>&gt; /ls\n</code></pre> <p>This displays two panels:</p> <ul> <li>Read-Only Files - Files available for reference</li> <li>Editable Files - Files the AI can modify</li> </ul>"},{"location":"concepts/file-context/#before-each-prompt","title":"Before Each Prompt","text":"<p>Byte automatically displays the current context before accepting your input, so you always know what files the AI can access.</p>"},{"location":"concepts/file-context/#removing-files","title":"Removing Files","text":""},{"location":"concepts/file-context/#single-files_1","title":"Single Files","text":"<p>Remove a file from context when it's no longer needed:</p> <pre><code>&gt; /drop old_file.py\nRemoved old_file.py from context\n</code></pre>"},{"location":"concepts/file-context/#multiple-files-with-wildcards_1","title":"Multiple Files with Wildcards","text":"<p>Remove multiple files using patterns:</p> <pre><code>&gt; /drop tests/**/*.py\n</code></pre> <p>This removes all Python test files from the context.</p>"},{"location":"concepts/file-context/#file-discovery","title":"File Discovery","text":"<p>Byte automatically discovers all files in your project on startup, respecting <code>.gitignore</code> patterns. This enables:</p> <ul> <li>Tab completion - Press Tab while typing file paths to see suggestions</li> <li>Fast lookups - File operations use a cached index for performance</li> <li>Automatic filtering - Git-ignored files are excluded from suggestions</li> </ul> <p>The discovery service:</p> <ol> <li>Scans your project directory recursively</li> <li>Loads <code>.gitignore</code> patterns and configuration ignore rules</li> <li>Builds an in-memory index of available files</li> <li>Updates the index when files change (if file watching is enabled)</li> </ol>"},{"location":"concepts/file-context/#ignore-patterns","title":"Ignore Patterns","text":"<p>Files are automatically excluded based on:</p> <ol> <li><code>.gitignore</code> rules - Standard git ignore patterns from your project's <code>.gitignore</code> file</li> <li>Configuration patterns - Custom ignore rules defined in <code>.byte/config.yaml</code></li> </ol> <p>You can add additional ignore patterns in your <code>.byte/config.yaml</code>:</p> <pre><code>files:\n  ignore:\n    - .byte/cache\n    - .ruff_cache\n    - \"*.log\"\n    - build/\n</code></pre> <p>These patterns use gitignore-style syntax and are combined with your <code>.gitignore</code> rules. Patterns support:</p> <ul> <li><code>*</code> - Wildcard for any characters</li> <li><code>**</code> - Matches directories recursively</li> <li><code>?</code> - Single character match</li> <li>Negation with <code>!</code> prefix</li> <li>Directory-specific patterns with trailing <code>/</code></li> </ul> <p>See the Settings Reference for complete configuration options.</p>"},{"location":"concepts/file-context/#best-practices","title":"Best Practices","text":""},{"location":"concepts/file-context/#start-small","title":"Start Small","text":"<p>Begin with only the files directly related to your task:</p> <pre><code>&gt; /add src/main.py\n&gt; /read-only config.yaml\n</code></pre> <p>Add more files as needed rather than loading everything upfront.</p>"},{"location":"concepts/file-context/#use-read-only-strategically","title":"Use Read-Only Strategically","text":"<p>Add reference files as read-only to provide context without risking unwanted changes:</p> <pre><code>&gt; /read-only docs/architecture.md\n&gt; /read-only .env.example\n</code></pre>"},{"location":"concepts/file-context/#context-in-ai-prompts","title":"Context in AI Prompts","text":"<p>When the AI receives your message, Byte includes a structured context block with all files:</p> <pre><code># Here are the files in the current context:\n\n## READ-ONLY FILES (for reference only):\n---\nsource: config.yaml\nmode: read-only\n---\n[file contents]\n\n## EDITABLE FILES (can be modified):\n---\nsource: src/main.py\nmode: editable\n---\n[file contents]\n</code></pre> <p>This format helps the AI understand:</p> <ul> <li>What files are available</li> <li>What permissions it has for each file</li> <li>The current state of each file</li> </ul>"},{"location":"concepts/file-context/#related-concepts","title":"Related Concepts","text":"<ul> <li>File Watching - Automatic context updates when files change</li> <li>Conventions - Project-specific guidelines automatically included in context</li> <li>Settings Reference - Configuration options for file handling</li> </ul>"},{"location":"concepts/file-watching/","title":"File Watching &amp; AI Comments","text":"<p>Byte automatically watches files in your project for changes. When it detects special AI comment markers, it can automatically add files to context and trigger actions.</p>"},{"location":"concepts/file-watching/#ai-comment-markers","title":"AI Comment Markers","text":"<p>Byte recognizes four types of AI comment markers, each triggering different behavior:</p>"},{"location":"concepts/file-watching/#editable-marker-ai","title":"Editable marker (<code>AI:</code>)","text":"<p>Used for standard code modification requests. Files are added to context as editable, allowing the AI to propose SEARCH/REPLACE blocks.</p> <p>Marker Quick Reference:</p> <p>AI: - Request code modifications (editable mode) AI @ - Provide reference context (read-only mode) AI ? - Ask questions about code (read-only mode, no changes) AI ! - Mark urgent/critical issues (editable mode, highest priority) Read-only marker (AI@)</p> <p>Used to provide reference context without allowing modifications. Files are added as read-only.</p>"},{"location":"concepts/file-watching/#ai-reference-this-pattern-for-other-implementations","title":"AI@ Reference this pattern for other implementations","text":"<p>class BaseHandler: def handle(self): pass</p> <p>Behavior:</p> <p>\u2022 File added to context in read-only mode \u2022 AI can reference the code but cannot propose changes \u2022 Useful for providing examples or patterns to follow</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Question marker (AI?)</p> <p>Used to ask questions about code. The AI provides answers and recommendations without making changes.</p> <p>Before (problematic code):</p>"},{"location":"concepts/file-watching/#ai-should-this-use-a-context-manager-instead","title":"AI? Should this use a context manager instead?","text":"<p>file = open(\"data.txt\") data = file.read() file.close()</p> <p>Behavior:</p> <p>\u2022 File added to context in read-only mode \u2022 AI analyzes the code and provides recommendations \u2022 No code changes are proposed \u2022 Response includes best practices and alternatives</p> <p>Example AI Response:</p> <p>Yes, this should definitely use a context manager. The current code has several issues:</p> <ol> <li>If an exception occurs between open() and close(), the file remains open</li> <li>Manual resource management is error-prone</li> <li>Not following Python best practices</li> </ol> <p>Recommended approach:</p> <pre><code># Improved version using context manager\nwith open(\"data.txt\") as file:\n    data = file.read()\n# File automatically closed when exiting the with block\n\n\nBenefits:\n\n \u2022 Automatic cleanup even if exceptions occur\n \u2022 More Pythonic and readable\n \u2022 Follows RAII pattern and prevents resource leaks\n\n\n\n---\n\n### Urgent task marker (`AI!`)\n\nUsed for critical issues requiring immediate attention. Takes priority over other markers.\n\n```python\n# AI! Fix this security vulnerability immediately\npassword = request.args.get('password')  # Plain text password in GET request!\n\n\nBehavior:\n\n \u2022 File added to context in editable mode\n \u2022 Takes highest priority if multiple AI comments exist\n \u2022 AI proposes immediate fixes using SEARCH/REPLACE blocks\n \u2022 Clear indication this is a critical issue\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nHow It Works\n\nDetection Flow\n\n 1 File change detected: Byte's watcher service detects when you save a file\n 2 AI comment scan: File content is scanned for AI:, AI@, AI?, or AI! markers\n 3 Auto-add to context: File is automatically added with appropriate mode:\n    \u2022 AI: or AI! \u2192 Editable mode\n    \u2022 AI@ or AI? \u2192 Read-only mode\n 4 Prompt interruption: Current prompt is interrupted to process the AI comment\n 5 AI response: AI processes the comment based on marker type:\n    \u2022 : or ! \u2192 Proposes code changes (CoderAgent)\n    \u2022 ? \u2192 Provides analysis and answers (AskAgent)\n    \u2022 @ \u2192 References the code as context\n\nWorkflow steps:\n\n1. You add an AI comment in your editor\n2. Save the file\n3. Byte automatically:\n   - Detects the AI comment marker\n   - Adds the file to context (editable for `AI:` and `AI!`, read-only for `AI@`)\n   - Interrupts the current prompt\n   - Shows you the AI comment\n   - Asks the AI to implement the requested changes\n4. AI responds with SEARCH/REPLACE blocks showing proposed changes\n5. You review and approve or reject the changes\n6. If approved, changes are applied and linters run automatically (if enabled)\n\n**Multiple comments:**\n\nIf multiple AI comments are detected, they're processed together based on priority:\n\n1. `AI!` (urgent) takes precedence\n2. Then `AI?` (questions)\n3. Then `AI:` (regular tasks)\n</code></pre>"},{"location":"concepts/lint/","title":"Linting","text":"<p>Byte's linting system automatically runs configured code quality tools on your files to identify and fix issues. It integrates seamlessly with your workflow, running linters on changed files or specific contexts with a simple command.</p> <p></p>"},{"location":"concepts/lint/#quick-start","title":"Quick Start","text":"<p>Run linters on all changed files:</p> <pre><code>&gt; /lint\n</code></pre> <p>Byte will:</p> <ol> <li>Stage your current changes with git</li> <li>Identify files modified since last commit</li> <li>Run configured linters based on file extensions</li> <li>Display results with error details</li> <li>Optionally attempt AI-assisted fixes for errors</li> </ol>"},{"location":"concepts/lint/#configuration","title":"Configuration","text":"<p>Configure linters in <code>.byte/config.yaml</code>:</p> <pre><code>lint:\n  enable: true\n  commands:\n    - command: \"uv run ruff format --force-exclude --respect-gitignore\"\n      extensions: [\".py\"]\n    - command: \"uv run ruff check --fix --force-exclude\"\n      extensions: [\".py\"]\n    - command: \"prettier --write\"\n      extensions: [\".md\"]\n    - command: \"keep-sorted\"\n      extensions: [\"*\"]\n</code></pre>"},{"location":"concepts/lint/#configuration-options","title":"Configuration Options","text":"<p>For complete configuration details, see the Settings Reference.</p> <p><code>lint.enable</code> (boolean, default: <code>true</code>)</p> <ul> <li>Enable or disable the linting functionality entirely</li> </ul> <p><code>lint.commands</code> (array)</p> <ul> <li>List of lint commands to execute</li> </ul> <p>Each command object has:</p> <p><code>command</code> (string, required)</p> <ul> <li>The shell command to execute (e.g., <code>\"ruff check --fix\"</code>)</li> <li>Command runs from project root directory</li> <li>Use full paths or ensure tools are in PATH</li> </ul> <p><code>extensions</code> (array of strings, required)</p> <ul> <li>File extensions this command applies to (e.g., <code>[\".py\", \".pyi\"]</code>)</li> <li>Use <code>[\"*\"]</code> to run on all files regardless of extension</li> <li>Match is done on file suffix</li> </ul>"},{"location":"concepts/lint/#how-it-works","title":"How It Works","text":"<p>For each lint command:</p> <ol> <li>Filter Files - Select files matching the command's extensions</li> <li>Build Commands - Construct full command: <code>{command} {file_path}</code></li> <li>Execute Async - Run commands concurrently for performance</li> <li>Capture Output - Collect stdout, stderr, and exit codes</li> <li>Report Results - Display summary with errors and warnings</li> </ol>"},{"location":"concepts/lint/#ai-assisted-fixes","title":"AI-Assisted Fixes","text":"<p>When lint errors are found, Byte can attempt automated fixes:</p> <pre><code>Attempt to fix lint errors? (y/N):\n</code></pre> <p>If you confirm:</p> <ol> <li>Coder Agent - Byte invokes the coder agent for each file</li> <li>Error Context - Provides the lint error message and file path</li> <li>Suggested Fix - AI proposes SEARCH/REPLACE blocks to resolve the issue</li> <li>Review - You review and approve the changes</li> </ol> <p>This is particularly useful for:</p> <ul> <li>Formatting issues the linter couldn't auto-fix</li> <li>Complex refactoring suggested by linters</li> <li>Understanding why a lint rule failed</li> </ul>"},{"location":"concepts/lint/#order-matters","title":"Order Matters","text":"<p>Run formatters before linters:</p> <pre><code>commands:\n  - command: \"ruff format\" # Format first\n    extensions: [\".py\"]\n  - command: \"ruff check --fix\" # Then check\n    extensions: [\".py\"]\n</code></pre> <p>This prevents formatters from introducing new lint errors.</p>"},{"location":"concepts/lint/#keep-commands-fast","title":"Keep Commands Fast","text":"<p>Use caching and incremental modes:</p> <pre><code>- command: \"mypy --cache-dir=.mypy_cache\"\n  extensions: [\".py\"]\n</code></pre>"},{"location":"concepts/lsp/","title":"LSP (Language Server Protocol)","text":"<p>Byte's LSP integration provides code intelligence features like hover information, go-to-definition, find references, and completions by connecting to language servers. It manages multiple LSP servers simultaneously, routing requests to the appropriate server based on file extensions.</p> <p></p>"},{"location":"concepts/lsp/#quick-start","title":"Quick Start","text":""},{"location":"concepts/lsp/#enable-lsp","title":"Enable LSP","text":"<p>Configure LSP in <code>.byte/config.yaml</code>:</p> <pre><code>lsp:\n  enable: true\n  timeout: 30\n  servers:\n    typescript:\n      command: [\"typescript-language-server\", \"--stdio\"]\n      file_extensions: [\"ts\", \"tsx\", \"js\", \"jsx\"]\n    python:\n      command: [\"pylsp\"]\n      file_extensions: [\"py\", \"pyi\"]\n</code></pre>"},{"location":"concepts/lsp/#use-with-research-agent","title":"Use with Research Agent","text":"<p>LSP tools are only available through the <code>/research</code> command:</p> <pre><code>&gt; /research Find all references to the UserService class\n</code></pre> <p>The research agent will use LSP tools like <code>find_references</code>, <code>get_definition</code>, and <code>get_hover_info</code> to analyze your codebase and provide detailed findings.</p> <p>Research findings are saved to session context rather than the conversation history. This allows other agents to reference the research results without cluttering the message thread. The findings remain available throughout your session for the AI to use when making decisions or generating code.</p> <p>Byte will:</p> <ol> <li>Start configured LSP servers in the background on boot</li> <li>Automatically open documents when you add them to context</li> <li>Provide code intelligence through LSP tools to the research agent</li> <li>Route requests to the appropriate server based on file extension</li> </ol>"},{"location":"concepts/lsp/#configuration","title":"Configuration","text":""},{"location":"concepts/lsp/#server-configuration","title":"Server Configuration","text":"<p>Each LSP server requires:</p> <p><code>command</code> (array of strings, required)</p> <ul> <li>Command and arguments to start the LSP server</li> <li>Example: <code>[\"typescript-language-server\", \"--stdio\"]</code></li> <li>Server must support stdio communication</li> </ul> <p><code>file_extensions</code> (array of strings, required)</p> <ul> <li>File extensions this server handles</li> <li>Example: <code>[\"ts\", \"tsx\", \"js\", \"jsx\"]</code></li> <li>Used to route requests to correct server</li> </ul> <p><code>initialization_options</code> (object, optional)</p> <ul> <li>Custom initialization options passed to the server</li> <li>Server-specific configuration</li> </ul>"},{"location":"concepts/lsp/#example-configuration","title":"Example Configuration","text":"<pre><code>lsp:\n  enable: true\n  timeout: 30\n  servers:\n    typescript:\n      command: [\"typescript-language-server\", \"--stdio\"]\n      file_extensions: [\"ts\", \"tsx\", \"js\", \"jsx\"]\n      initialization_options:\n        preferences:\n          includeInlayParameterNameHints: \"all\"\n\n    python:\n      command: [\"pylsp\"]\n      file_extensions: [\"py\", \"pyi\"]\n      initialization_options:\n        pylsp:\n          plugins:\n            pycodestyle:\n              enabled: false\n\n    rust:\n      command: [\"rust-analyzer\"]\n      file_extensions: [\"rs\"]\n</code></pre> <p>See the Settings Reference for complete configuration options.</p>"},{"location":"concepts/lsp/#available-tools","title":"Available Tools","text":"<p>The Research Agent (<code>/research</code> command) has exclusive access to LSP functionality through these tools. Other agents do not have access to LSP features.</p>"},{"location":"concepts/lsp/#get-hover-information","title":"Get Hover Information","text":"<p>Get documentation and type information for a symbol:</p> <pre><code>get_hover_info(file_path=\"src/main.ts\", line=10, character=5)\n</code></pre> <p>Returns:</p> <ul> <li>Documentation strings</li> <li>Type signatures</li> <li>Parameter information</li> </ul>"},{"location":"concepts/lsp/#go-to-definition","title":"Go to Definition","text":"<p>Find where a symbol is defined:</p> <pre><code>get_definition(file_path=\"src/main.ts\", line=10, character=5)\n</code></pre> <p>Returns:</p> <ul> <li>Definition location(s)</li> <li>File path and line/column range</li> <li>Code context around definition</li> </ul>"},{"location":"concepts/lsp/#find-references","title":"Find References","text":"<p>Find all references to a symbol:</p> <pre><code>find_references(file_path=\"src/main.ts\", line=10, character=5, include_declaration=False)\n</code></pre> <p>Returns:</p> <ul> <li>All reference locations grouped by file</li> <li>Code context for each reference</li> <li>Line and column information</li> </ul>"},{"location":"concepts/lsp/#related-concepts","title":"Related Concepts","text":"<ul> <li>File Context - Files must be in context for LSP to work</li> <li>Conventions - Document language-specific patterns</li> <li>Settings Reference - Complete LSP configuration options</li> </ul>"},{"location":"concepts/memory/","title":"Memory &amp; Context Management","text":"<p>Byte's approach to memory and context is designed to keep conversations focused, reduce token usage, and encourage best practices through deliberate constraints. Understanding how Byte manages context helps you work more effectively with the AI.</p> <p></p>"},{"location":"concepts/memory/#analytics-context-tracking","title":"Analytics &amp; Context Tracking","text":"<p>Byte displays an analytics bar after each AI interaction, providing real-time feedback about token usage and context consumption. The bar features statistics about the current session but also includes a progress bar showing you how much of the agent's input context has been used.</p> <p>This visual indicator helps you manage input context effectively - you can see at a glance when you're approaching context limits and should consider removing files that are no longer being used.</p> <p>The analytics panel shows:</p> <ul> <li>Memory usage progress bar - Visual representation of context consumption</li> <li>Token statistics - Sent and received tokens for the last message</li> <li>Cost tracking - Per-message and session-total costs</li> </ul>"},{"location":"concepts/memory/#no-persistent-memory","title":"No Persistent Memory","text":"<p>Byte does not persist conversation history between sessions. When you exit and restart Byte, the AI starts fresh with no memory of previous conversations.</p>"},{"location":"concepts/memory/#why-no-persistence","title":"Why No Persistence?","text":"<p>This design choice serves several purposes:</p> <p>Keeps You Honest</p> <ul> <li>Forces clear, explicit communication in each session</li> <li>Prevents relying on unstated context from previous conversations</li> <li>Encourages complete problem descriptions</li> </ul> <p>Reduces Context Size</p> <ul> <li>No accumulation of stale conversation history</li> <li>Lower token costs per interaction</li> <li>Faster response times</li> </ul> <p>Encourages Documentation</p> <ul> <li>Important patterns belong in Conventions, not chat history</li> <li>Knowledge becomes project documentation, not hidden in logs</li> <li>Team members benefit from documented standards</li> </ul>"},{"location":"concepts/memory/#when-to-create-conventions","title":"When to Create Conventions","text":"<p>If the AI consistently follows a pattern or standard you've explained:</p> <pre><code>&gt; The AI keeps suggesting async/await patterns for our services\n\n\u2713 Create a convention file documenting your async patterns\n\u2717 Don't rely on explaining it in every session\n</code></pre> <p>Add it to <code>.byte/conventions/</code>:</p> <pre><code># Async Patterns\n\nAll service methods must be async:\n\n\\`\\`\\`python\nclass MyService(Service):\nasync def process(self) -&gt; bool:\nresult = await self.operation()\nreturn result\n\\`\\`\\`\n</code></pre> <p>Now the AI knows this rule in every session without you repeating it.</p>"},{"location":"concepts/memory/#smart-block-removal","title":"Smart Block Removal","text":"<p>To keep the AI focused on current code state and reduce input context, Byte removes SEARCH/REPLACE blocks from historic messages after they're processed.</p>"},{"location":"concepts/memory/#how-it-works","title":"How It Works","text":"<p>After the AI generates SEARCH/REPLACE blocks:</p> <ol> <li>Blocks are applied to your files (with your approval)</li> <li>Historic messages are masked - blocks are replaced with summaries</li> <li>Fresh file content is provided from the file context</li> <li>AI sees current state - not outdated proposed changes</li> </ol>"},{"location":"concepts/memory/#example-transformation","title":"Example Transformation","text":"<p>Original AI Message:</p> <pre><code>Here's how to fix that:\n\n'''python\n+++++++ src/main.py\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; SEARCH\ndef old_function():\npass\n=======\ndef new_function():\nreturn True\n\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; REPLACE\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; '''\n\nThis change updates the function to return a boolean.\n</code></pre> <p>After Processing (in chat history):</p> <pre><code>Here's how to fix that:\n\n'''python\n_[Changes applied to `src/main.py` - search/replace block removed]_\n'''\n\nThis change updates the function to return a boolean.\n</code></pre>"},{"location":"concepts/memory/#why-remove-blocks","title":"Why Remove Blocks?","text":"<p>Prevents Confusion</p> <ul> <li>If you corrected the AI's code after applying blocks, the old suggestions disappear</li> <li>The AI only sees what's actually in the files now</li> <li>No conflicting versions of code in context</li> </ul> <p>Saves Tokens</p> <ul> <li>SEARCH/REPLACE blocks are verbose</li> <li>Historic blocks consume input context without adding value</li> <li>More tokens available for relevant information</li> </ul> <p>Keeps AI On Task</p> <ul> <li>Focus on current problem, not past solutions</li> <li>Fresh perspective on each turn</li> <li>Reduces tendency to repeat previous patterns</li> </ul>"},{"location":"concepts/presets/","title":"Presets","text":"<p>Presets allow you to save and quickly load predefined configurations of files, conventions, and prompts. They're ideal for switching between different workflows, project contexts, or documentation tasks without manually adding files each time.</p> <p></p>"},{"location":"concepts/presets/#quick-start","title":"Quick Start","text":""},{"location":"concepts/presets/#loading-a-preset","title":"Loading a Preset","text":"<p>Load a preset configuration:</p> <pre><code>&gt; /preset command\n</code></pre> <p>Byte will:</p> <ol> <li>Prompt to clear conversation history (optional)</li> <li>Prompt to clear current file context (optional)</li> <li>Add configured read-only files to context</li> <li>Add configured editable files to context</li> <li>Load specified conventions</li> <li>Set a default prompt (if configured)</li> </ol>"},{"location":"concepts/presets/#saving-a-preset","title":"Saving a Preset","text":"<p>Save your current context as a preset:</p> <pre><code>&gt; /preset:save\nEnter a name for this preset: my-workflow\nEnter a default prompt for this preset (leave blank to skip):\nPreset 'my-workflow' saved successfully\n</code></pre> <p>Byte will:</p> <ol> <li>Prompt for a preset name</li> <li>Capture current read-only files</li> <li>Capture current editable files</li> <li>Capture loaded conventions</li> <li>Optionally set a default prompt</li> <li>Save the configuration to <code>.byte/config.yaml</code></li> </ol>"},{"location":"concepts/presets/#configuration","title":"Configuration","text":"<p>Define presets in <code>.byte/config.yaml</code>:</p> <pre><code>presets:\n  - id: command\n    conventions:\n      - CODE_STYLEGUIDE.md\n      - PROJECT_ARCHITECTURE.md\n    read_only_files:\n      - src/byte/bootstrap.py\n      - src/byte/container.py\n    editable_files:\n      - src/byte/domain/cli/command/new_command.py\n    prompt: \"Create a new command following the existing patterns\"\n    load_on_boot: false\n</code></pre>"},{"location":"concepts/presets/#configuration-options","title":"Configuration Options","text":"<p>For complete configuration details, see the Settings Reference.</p> <p><code>id</code> (string, required)</p> <ul> <li>Unique identifier used in <code>/preset &lt;id&gt;</code> command</li> <li>Use descriptive names like \"command\", \"docs\", or \"testing\"</li> </ul> <p><code>read_only_files</code> (array of strings, default: <code>[]</code>)</p> <ul> <li>Files to add as read-only context</li> <li>Supports glob patterns like <code>src/**/*.py</code></li> <li>Files are visible to AI but cannot be modified</li> </ul> <p><code>editable_files</code> (array of strings, default: <code>[]</code>)</p> <ul> <li>Files to add as editable context</li> <li>Supports glob patterns</li> <li>AI can propose changes to these files</li> </ul> <p><code>conventions</code> (array of strings, default: <code>[]</code>)</p> <ul> <li>Convention files to load from <code>.byte/conventions/</code></li> <li>Provide coding standards and style guides to the AI</li> </ul> <p><code>prompt</code> (string, optional)</p> <ul> <li>Default prompt text to populate the input field</li> <li>Useful for repetitive tasks with similar instructions</li> </ul> <p><code>load_on_boot</code> (boolean, default: <code>false</code>)</p> <ul> <li>Automatically load this preset when Byte starts</li> <li>Only one preset should have this enabled</li> </ul>"},{"location":"concepts/presets/#saving-presets","title":"Saving Presets","text":"<p>Instead of manually editing <code>.byte/config.yaml</code>, you can save your current context as a preset using the <code>/preset:save</code> command.</p>"},{"location":"concepts/presets/#how-it-works","title":"How It Works","text":"<p>The save command captures your current workspace state:</p> <pre><code>&gt; /preset:save\nEnter a name for this preset: documentation\nEnter a default prompt for this preset (leave blank to skip): Write documentation for\nPreset 'documentation' saved successfully\n</code></pre> <p>The preset ID is automatically generated from your name (e.g., \"My Workflow\" becomes \"my-workflow\").</p>"},{"location":"concepts/presets/#what-gets-saved","title":"What Gets Saved","text":"<ul> <li>Read-only files - All files currently in read-only context</li> <li>Editable files - All files currently in editable context</li> <li>Conventions - All loaded convention files</li> <li>Default prompt - Optional prompt text to pre-fill the input</li> </ul>"},{"location":"concepts/presets/#workflow","title":"Workflow","text":"<ol> <li>Set up your ideal context with <code>/add</code> and <code>/read-only</code></li> <li>Load relevant conventions</li> <li>Run <code>/preset:save</code> to capture the configuration</li> <li>Give it a descriptive name</li> <li>Optionally add a default prompt</li> <li>The preset is immediately available for use</li> </ol> <p>This is particularly useful when you discover a context configuration that works well and want to reuse it later.</p>"},{"location":"concepts/presets/#common-use-cases","title":"Common Use Cases","text":""},{"location":"concepts/presets/#command-development","title":"Command Development","text":"<p>Create a preset for building new CLI commands:</p> <pre><code>presets:\n  - id: command\n    conventions:\n      - CODE_STYLEGUIDE.md\n      - PROJECT_ARCHITECTURE.md\n    read_only_files:\n      - src/byte/domain/cli/service/command_registry.py\n      - src/byte/core/mixins/user_interactive.py\n    editable_files:\n      - src/byte/domain/*/command/*.py\n</code></pre> <p>Load it when working on commands:</p> <pre><code>&gt; /preset command\n</code></pre>"},{"location":"concepts/presets/#documentation-writing","title":"Documentation Writing","text":"<p>Set up a preset for documentation tasks:</p> <pre><code>presets:\n  - id: mkdocs\n    conventions:\n      - MKDOCS_STYLEGUIDE.md\n    read_only_files:\n      - docs/concepts/file-context.md\n      - docs/concepts/lint.md\n    editable_files:\n      - docs/concepts/new-feature.md\n    prompt: \"Using the MKDOCS_STYLEGUIDE and existing docs as examples, document \"\n</code></pre> <p>The preset includes example docs as reference and sets a helpful default prompt.</p>"},{"location":"concepts/presets/#testing-workflow","title":"Testing Workflow","text":"<p>Configure a preset for test development:</p> <pre><code>presets:\n  - id: testing\n    conventions:\n      - TESTING_STYLEGUIDE.md\n    read_only_files:\n      - src/byte/domain/*/service/*.py\n    editable_files:\n      - tests/**/*_test.py\n    prompt: \"Write tests for \"\n</code></pre>"},{"location":"concepts/presets/#workflow-integration","title":"Workflow Integration","text":""},{"location":"concepts/presets/#history-management","title":"History Management","text":"<p>When loading a preset, you can optionally clear conversation history:</p> <pre><code>Would you like to clear the conversation history before loading this preset? (Y/n):\n</code></pre> <p>Choose Yes to start fresh with the new context, or No to preserve previous conversation while switching files.</p>"},{"location":"concepts/presets/#context-management","title":"Context Management","text":"<p>You can also clear the current file context:</p> <pre><code>Would you like to clear the file context before loading this preset? (y/N):\n</code></pre> <p>Choose Yes to replace all files with the preset configuration, or No to add preset files to existing context.</p>"},{"location":"concepts/presets/#auto-loading","title":"Auto-Loading","text":"<p>Set <code>load_on_boot: true</code> to automatically load a preset when Byte starts:</p> <pre><code>presets:\n  - id: default\n    load_on_boot: true\n    editable_files:\n      - src/**/*.py\n</code></pre> <p>This is useful for projects where you always work with the same initial context.</p>"},{"location":"concepts/presets/#related-concepts","title":"Related Concepts","text":"<ul> <li>File Context - Understanding file modes and context management</li> <li>Conventions - Project-specific coding standards</li> <li>Settings Reference - Complete configuration options</li> </ul>"},{"location":"concepts/web/","title":"Web","text":"<p>Byte's web command allows you to scrape web pages and convert them to markdown format for use in your AI conversations. It uses headless Chrome to fetch pages, handles JavaScript-rendered content, and converts HTML to clean markdown that can be added to the LLM context.</p> <p></p>"},{"location":"concepts/web/#quick-start","title":"Quick Start","text":"<p>Scrape a webpage:</p> <pre><code>&gt; /web https://example.com\n</code></pre> <p>Byte will:</p> <ol> <li>Launch headless Chrome browser</li> <li>Navigate to the URL and wait for JavaScript to render</li> <li>Extract the page content</li> <li>Convert HTML to markdown format</li> <li>Display the formatted content</li> <li>Prompt you to add it to the LLM context</li> </ol>"},{"location":"concepts/web/#configuration","title":"Configuration","text":"<p>Configure web functionality in <code>.byte/config.yaml</code>:</p> <pre><code>web:\n  enable: true\n  chrome_binary_location: /usr/bin/google-chrome\n</code></pre> <p>For complete configuration details, see the Settings Reference.</p>"},{"location":"concepts/web/#context-integration","title":"Context Integration","text":"<p>After displaying the content, you have three options:</p> <p></p>"},{"location":"concepts/web/#yes","title":"Yes","text":"<p>Add raw markdown directly to context</p> <p>The content is stored with a key derived from the URL slug for easy reference.</p>"},{"location":"concepts/web/#clean-with-llm","title":"Clean with LLM","text":"<p>Use AI to extract relevant information</p> <p>The cleaner agent:</p> <ul> <li>Removes navigation, footers, and boilerplate</li> <li>Extracts main content and key points</li> <li>Formats it for optimal LLM comprehension</li> <li>Adds cleaned version to context</li> </ul>"},{"location":"concepts/web/#no","title":"No","text":"<p>Discard the content</p> <p>The scraped content is not added to the context.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>To help you get started with Byte, we'll cover a few important topics:</p> <ul> <li>Installing Byte</li> <li>First steps after installation</li> </ul> <p>Read on, or jump ahead to another section:</p> <ul> <li>Learn more about the core concepts in Byte</li> </ul>"},{"location":"getting-started/first-steps/","title":"First Steps","text":"<p>Configure Byte and run your first session.</p>"},{"location":"getting-started/first-steps/#prerequisites","title":"Prerequisites","text":"<p>Before running Byte:</p> <ul> <li>Git repository - Byte operates inside a git repository</li> <li>Good terminal - A modern terminal emulator with proper rendering support (like Kitty, Foot, WezTerm, or Alacritty)</li> <li>API key - One of these environment variables must be set:</li> <li><code>ANTHROPIC_API_KEY</code> for Claude models</li> <li><code>GEMINI_API_KEY</code> for Google Gemini</li> <li><code>OPENAI_API_KEY</code> for OpenAI models</li> </ul>"},{"location":"getting-started/first-steps/#configuration","title":"Configuration","text":""},{"location":"getting-started/first-steps/#set-your-api-key","title":"Set Your API Key","text":"<p>Export the environment variable for your chosen provider:</p> <pre><code>$ export ANTHROPIC_API_KEY=your-key-here\n</code></pre> <p>Or create a <code>.env</code> file in your project root:</p> <pre><code>$ echo \"ANTHROPIC_API_KEY=your-key-here\" &gt; .env\n</code></pre>"},{"location":"getting-started/first-steps/#navigate-to-your-project","title":"Navigate to Your Project","text":"<p>Byte runs from within a git repository:</p> <pre><code>$ cd /path/to/your/project\n$ git init  # If not already a git repo\n</code></pre>"},{"location":"getting-started/first-steps/#running-byte","title":"Running Byte","text":"<p>Launch Byte from your project directory:</p> <pre><code>$ byte\n</code></pre> <p>On first run, Byte's <code>FirstBootService</code> will guide you through initial setup:</p> <ol> <li>Choose LLM Provider - Select your preferred AI provider (Anthropic, Gemini, or OpenAI)</li> <li>Configure Web Commands - Automatically detects Chrome/Chromium for web scraping</li> <li>Enable File Watching - Optionally enable automatic detection of AI comment markers</li> <li>Setup .gitignore - Adds <code>.byte/cache</code> and <code>.byte/session_context</code> patterns</li> </ol> <p>The service creates:</p> <ul> <li><code>.byte/</code> directory in your project root</li> <li><code>config.yaml</code> with your selected configuration</li> <li><code>conventions/</code> directory for project-specific coding standards</li> <li><code>context/</code> directory for session context</li> <li><code>cache/</code> directory for temporary files</li> </ul>"},{"location":"getting-started/first-steps/#the-byte-directory","title":"The .byte Directory","text":"<p>Byte creates a <code>.byte/</code> directory containing:</p> <ul> <li>config.yaml - Configuration settings for model selection, tool availability, and behavior (see Settings Reference)</li> <li>cache/ - Temporary data and performance optimizations</li> <li>conventions/ - Project-specific style guides and coding standards that are automatically included in the AI's context</li> </ul> <p>See the Conventions guide to learn how to define project-specific coding standards that Byte automatically includes in the AI's context.</p>"},{"location":"getting-started/first-steps/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/first-steps/#adding-files-to-context","title":"Adding Files to Context","text":"<p>The AI needs to know about files before suggesting changes:</p> <pre><code>/add src/main.py\n</code></pre> <p></p>"},{"location":"getting-started/first-steps/#making-changes","title":"Making Changes","text":"<p>Ask Byte to modify code:</p> <pre><code>&gt; Refactor the main function to use dependency injection\n</code></pre> <p>Review the proposed changes, then approve or reject them.</p> <p>Learn how to work with files in the AI's context - see File Context for details on adding, viewing, and removing files.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Install Byte using your preferred Python package manager. Once installed, you'll have a <code>byte</code> command available in your terminal.</p>"},{"location":"getting-started/installation/#installing-byte","title":"Installing Byte","text":""},{"location":"getting-started/installation/#using-uv","title":"Using uv","text":"<p>The fastest installation method uses uv, a modern Python package installer:</p> <pre><code>$ curl -LsSf https://astral.sh/uv/install.sh | sh\n$ uv tool install byte-ai-cli\n</code></pre>"},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<p>Install with pip if you prefer traditional Python tooling:</p> <pre><code>$ pip install byte-ai-cli\n</code></pre>"},{"location":"getting-started/installation/#using-nix-flakes","title":"Using Nix Flakes","text":"<p>For NixOS users or those with Nix flakes enabled, add to your configuration:</p> <pre><code>{\n  inputs = {\n    byte.url = \"github:UseTheFork/byte\";\n  };\n}\n</code></pre> <p>Include in your system packages:</p> <pre><code>environment.systemPackages = [\n  inputs.byte.packages.${system}.default\n];\n</code></pre> <p>Or run directly without installation:</p> <pre><code>$ nix run github:UseTheFork/byte\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Confirm the installation succeeded:</p> <p>Tip</p> <p>Before running Byte, you must have at least one of these environment variables set: <code>ANTHROPIC_API_KEY</code>, <code>GEMINI_API_KEY</code>, or <code>OPENAI_API_KEY</code>. See First Steps for configuration details.</p> <pre><code>$ byte\n</code></pre> <p>You should see the following screen after startup.</p> <p></p>"},{"location":"getting-started/workflow-example/","title":"Workflow Example","text":"<p>This guide demonstrates a complete workflow for adding a feature to Byte using domain-driven development practices. You'll learn how to manage context, reference existing patterns, and iterate on changes with the AI.</p> <p>Byte works best when your project uses Domain-Driven Design (DDD) for both frontend and backend. You can feed an entire domain into the read-only context, making it easy to provide the AI with a template to follow.</p> <p>In this example, we'll add a progress display to the web command. This workflow uses the CLI, but it can be done just as easily using file watching and AI commands.</p>"},{"location":"getting-started/workflow-example/#step-1-add-files-to-editable-context","title":"Step 1: Add Files to Editable Context","text":"<p>First, add the files Byte will modify to the editable context. Since the web command resides in the web domain, add the entire domain for editing:</p> <pre><code>/add src/byte/domain/web/**\n</code></pre> <p></p> <p>All files in the web domain are now in the editable context.</p>"},{"location":"getting-started/workflow-example/#step-2-add-reference-files","title":"Step 2: Add Reference Files","text":"<p>Next, add reference files to the read-only context. This can be an entire domain or just a few files. The key is adding them as read-only so the AI can reference them without making changes.</p> <p>In this case, the rune spinner is used in only one file, so add the component and its implementation to the read-only context:</p> <pre><code>/read-only src/byte/domain/cli/rich/rune_spinner.py\n/read-only src/byte/domain/cli/service/stream_rendering_service.py\n</code></pre> <p></p> <p>Now the editable files and read-only reference files are both in context.</p>"},{"location":"getting-started/workflow-example/#step-3-add-external-documentation","title":"Step 3: Add External Documentation","text":"<p>At this point, you could ask the agent to complete the change. However, since the web scraping implementation uses <code>pydoll</code>, it's a good idea to include some of the documentation in the context as well. Use the <code>/web</code> command for this:</p> <pre><code>/web https://pydoll.tech/docs/\n</code></pre> <p></p> <p>Once scraped, Byte asks if you want to add the content as-is, clean it up using the weak model, or cancel. It's usually good practice to clean up scraped content, but since this feature is small, keep it as-is.</p> <p></p> <p>Now that all the pieces are together, ask Byte to make the change.</p>"},{"location":"getting-started/workflow-example/#step-4-request-the-change","title":"Step 4: Request the Change","text":"<p>You can request the change in two different ways:</p> <p>Option A: Use <code>/ask</code> first</p> <p>Use the <code>/ask</code> command to see how Byte recommends making this change. Because <code>ask</code> doesn't have tools or the ability to change files, it's a good way to discuss the change before Byte implements it. This is possible because memory is shared between main agents.</p> <p>Option B: Request directly</p> <p>Don't use any command and ask Byte to make the change directly. This is more of a YOLO move, but you can always press <code>Ctrl+C</code> to cancel generation mid-prompt.</p> <p>For this tutorial, use method A:</p> <pre><code>/ask How would you suggest we implement a rich Live using our Rune spinner while we are scraping web content in our ChromiumService\n</code></pre> <p></p> <p>The recommendation is close but not perfect. Depending on how close the response is, you may want to follow up with another <code>/ask</code>, but in this case, course correct while asking to implement:</p> <pre><code>Instead of calling `self.console = await self.make(ConsoleService)` at boot, call it at the start of `do_scrape`. Also use `with Live(table, refresh_per_second=4) as live:`\n</code></pre> <p></p> <p>Byte uses SEARCH/REPLACE blocks so you can see the changes as they happen.</p> <p>Once the change is applied, if you have lint commands enabled, Byte will run those commands against the changed files:</p> <p></p>"},{"location":"getting-started/workflow-example/#step-5-commit-the-change","title":"Step 5: Commit the Change","text":"<p>That's it! Since the change is complete, run the <code>/commit</code> command to lint the files and commit the change:</p> <pre><code>/commit\n</code></pre> <p></p> <p>You can now choose to keep asking for changes in the same manner, or use the <code>/clear</code> command to clear the chat history, or <code>/reset</code> to clear both history and context.</p> <p>If you continue making changes, remember to keep an eye on how much memory has been used:</p> <p></p>"},{"location":"getting-started/workflow-example/#related-concepts","title":"Related Concepts","text":"<ul> <li>File Context - Managing files in the AI's workspace</li> <li>Commit - AI-powered commit message generation</li> <li>Web - Scraping documentation for context</li> </ul>"},{"location":"reference/","title":"Introduction","text":""},{"location":"reference/commands/","title":"Commands","text":"<p>Byte provides a comprehensive set of commands for interacting with your codebase, managing context, and controlling the AI assistant. Commands are organized by category for easy reference.</p>"},{"location":"reference/commands/#system","title":"System","text":"<p><code>!&lt;command&gt;</code> - Execute a shell command and optionally add output to conversation context</p>"},{"location":"reference/commands/#agent","title":"Agent","text":""},{"location":"reference/commands/#ask","title":"<code>/ask</code>","text":"<pre><code>usage: ask ...\n\nAsk the AI agent a question or request assistance\n\npositional arguments:\n  ask_query  The user's question or query text\n</code></pre>"},{"location":"reference/commands/#research","title":"<code>/research</code>","text":"<pre><code>usage: research ...\n\nExecute research agent to gather codebase insights, analyze patterns, and save\ndetailed findings to session context for other agents\n\npositional arguments:\n  research_query  The research query or question to investigate\n</code></pre>"},{"location":"reference/commands/#clipboard","title":"Clipboard","text":""},{"location":"reference/commands/#copy","title":"<code>/copy</code>","text":"<pre><code>usage: copy [--type {message,block}]\n\nCopy code blocks from message history to clipboard\n\noptions:\n  --type {message,block}\n                        Filter code blocks by type (message or block)\n</code></pre>"},{"location":"reference/commands/#copydrop","title":"<code>/copy:drop</code>","text":"<pre><code>usage: copy:drop [--type {message,block}]\n\nClear code blocks from the clipboard session\n\noptions:\n  --type {message,block}\n                        Filter code blocks by type (message or block)\n</code></pre>"},{"location":"reference/commands/#config","title":"Config","text":""},{"location":"reference/commands/#configagent","title":"<code>/config:agent</code>","text":"<pre><code>usage: config:agent agent\n\nConfigure agent-specific settings\n\npositional arguments:\n  agent  Name of the agent to configure\n</code></pre>"},{"location":"reference/commands/#conventions","title":"Conventions","text":""},{"location":"reference/commands/#convention","title":"<code>/convention</code>","text":"<pre><code>usage: convention\n\nGenerate convention documents by analyzing codebase patterns and saving them\nto the conventions directory\n</code></pre>"},{"location":"reference/commands/#files","title":"Files","text":""},{"location":"reference/commands/#add","title":"<code>/add</code>","text":"<pre><code>usage: add file_path\n\nAdd file to context as editable\n\npositional arguments:\n  file_path  Path to file\n</code></pre>"},{"location":"reference/commands/#drop","title":"<code>/drop</code>","text":"<pre><code>usage: drop file_path\n\nRemove file from context\n\npositional arguments:\n  file_path  Path to file\n</code></pre>"},{"location":"reference/commands/#ls","title":"<code>/ls</code>","text":"<pre><code>usage: ls\n\nList all files currently in the AI context\n</code></pre>"},{"location":"reference/commands/#read-only","title":"<code>/read-only</code>","text":"<pre><code>usage: read-only file_path\n\nAdd file to context as read-only\n\npositional arguments:\n  file_path  Path to file\n</code></pre>"},{"location":"reference/commands/#reload","title":"<code>/reload</code>","text":"<pre><code>usage: reload\n\nReload project file discovery cache\n</code></pre>"},{"location":"reference/commands/#switch","title":"<code>/switch</code>","text":"<pre><code>usage: switch file_path\n\nSwitch file mode between editable and read-only\n\npositional arguments:\n  file_path  Path to file\n</code></pre>"},{"location":"reference/commands/#general","title":"General","text":""},{"location":"reference/commands/#commit","title":"<code>/commit</code>","text":"<pre><code>usage: commit\n\nCreate an AI-powered git commit with automatic staging and linting\n</code></pre>"},{"location":"reference/commands/#exit","title":"<code>/exit</code>","text":"<pre><code>usage: exit\n\nExit the Byte application gracefully\n</code></pre>"},{"location":"reference/commands/#lint","title":"<code>/lint</code>","text":"<pre><code>usage: lint\n\nRun configured linters on changed files or current context\n</code></pre>"},{"location":"reference/commands/#preset","title":"<code>/preset</code>","text":"<pre><code>usage: preset [--should-not-clear-history] [--should-not-clear-files]\n              [--silent]\n              preset_id\n\nLoad a predefined preset configuration with files and conventions\n\npositional arguments:\n  preset_id             ID of the preset to load\n\noptions:\n  --should-not-clear-history\n                        Do not clear conversation history before loading\n                        preset\n  --should-not-clear-files\n                        Do not clear file context before loading preset\n  --silent              Run silently without prompting for confirmations\n</code></pre>"},{"location":"reference/commands/#presetsave","title":"<code>/preset:save</code>","text":"<pre><code>usage: preset:save\n\nSave the current context as a preset configuration\n</code></pre>"},{"location":"reference/commands/#memory","title":"Memory","text":""},{"location":"reference/commands/#clear","title":"<code>/clear</code>","text":"<pre><code>usage: clear\n\nClear conversation history and start a new thread\n</code></pre>"},{"location":"reference/commands/#reset","title":"<code>/reset</code>","text":"<pre><code>usage: reset\n\nReset conversation history and clear file context completely\n</code></pre>"},{"location":"reference/commands/#show","title":"<code>/show</code>","text":"<pre><code>usage: show\n\nDisplay the current conversation history and context\n</code></pre>"},{"location":"reference/commands/#undo","title":"<code>/undo</code>","text":"<pre><code>usage: undo\n\nUndo the last conversation step by removing the most recent human message and\nall subsequent agent responses from the current thread\n</code></pre>"},{"location":"reference/commands/#session-context","title":"Session Context","text":""},{"location":"reference/commands/#context","title":"<code>/context</code>","text":"<pre><code>usage: context target\n\nAdd a file or URL to session context. Automatically detects the type and\nhandles appropriately.\n\npositional arguments:\n  target  Path to file or URL to add\n</code></pre>"},{"location":"reference/commands/#ctxdrop","title":"<code>/ctx:drop</code>","text":"<pre><code>usage: ctx:drop file_path\n\nRemove items from session context to clean up and reduce noise, improving AI\nfocus on current task\n\npositional arguments:\n  file_path  Path to file\n</code></pre>"},{"location":"reference/commands/#ctxfile","title":"<code>/ctx:file</code>","text":"<pre><code>usage: ctx:file file_path\n\nRead a file from disk and add its contents to the session context, making it\navailable to the AI for reference during the conversation\n\npositional arguments:\n  file_path  Path to file\n</code></pre>"},{"location":"reference/commands/#ctxls","title":"<code>/ctx:ls</code>","text":"<pre><code>usage: ctx:ls\n\nList all session context items\n</code></pre>"},{"location":"reference/commands/#web","title":"<code>/web</code>","text":"<pre><code>usage: web url\n\nFetch webpage using headless Chrome, convert HTML to markdown, display for\nreview, and optionally add to LLM context\n\npositional arguments:\n  url  URL to scrape\n</code></pre>"},{"location":"reference/settings/","title":"Byte Configuration Settings","text":"<p>Byte's configuration system uses a YAML file located at <code>.byte/config.yaml</code> to control all aspects of the application's behavior. Configuration is organized into logical sections covering CLI behavior, LLM providers, file handling, and feature-specific settings.</p>"},{"location":"reference/settings/#boot","title":"Boot","text":"Field Type Default Description <code>read_only_files</code> <code>array[string]</code> - Files to add to read-only context <code>editable_files</code> <code>array[string]</code> - Files to add to editable context"},{"location":"reference/settings/#cli","title":"Cli","text":"Field Type Default Description <code>ui_theme</code> <code>mocha, macchiato, latte, frappe</code> <code>mocha</code> Catppuccin theme variant for the CLI interface (mocha/macchiato are dark, latte is light, frappe is cool dark) <code>syntax_theme</code> <code>github-dark, bw, sas, staroffice, xcode, monokai, lightbulb, rrt</code> <code>monokai</code> Pygments theme for code block syntax highlighting in CLI output"},{"location":"reference/settings/#edit_format","title":"Edit_Format","text":"Field Type Default Description <code>enable_shell_commands</code> <code>boolean</code> <code>false</code> Enable execution of shell commands from AI responses. When disabled, shell command blocks will not be executed. <code>mask_message_count</code> <code>integer</code> <code>1</code> Number of recent AI messages to exclude from masking. Messages older than this count will have their SEARCH/REPLACE blocks removed to reduce token usage."},{"location":"reference/settings/#files","title":"Files","text":"Field Type Default Description <code>ignore</code> <code>array[string]</code> <code>['.byte/cache', '.ruff_cache', '.idea', '.venv', '.env', '.git', '.pytest_cache', '__pycache__', 'node_modules', 'dist']</code> List of gitignore-style patterns to exclude from file discovery. Patterns support wildcards and are combined with .gitignore rules."},{"location":"reference/settings/#files-watch","title":"Files &gt; Watch","text":"Field Type Default Description <code>enable</code> <code>boolean</code> <code>false</code> Enable file watching for AI comment markers (AI:, AI@, AI?, AI!). When enabled, Byte automatically detects changes and processes AI instructions."},{"location":"reference/settings/#git","title":"Git","text":"Field Type Default Description <code>enable_scopes</code> <code>boolean</code> <code>false</code> Enable scope selection for conventional commits <code>enable_breaking_changes</code> <code>boolean</code> <code>true</code> Enable breaking change detection and confirmation <code>enable_body</code> <code>boolean</code> <code>true</code> Enable commit message body generation <code>scopes</code> <code>array[string]</code> - Available scopes for conventional commits <code>description_guidelines</code> <code>array[string]</code> - Additional guidelines for commit descriptions <code>max_description_length</code> <code>integer</code> <code>72</code> Maximum character length for commit descriptions"},{"location":"reference/settings/#lint","title":"Lint","text":"<p>Code linting and formatting configuration</p> Field Type Default Description <code>enable</code> <code>boolean</code> <code>false</code> Enable or disable the linting functionality <code>commands</code> <code>array[LintCommand]</code> <code>[]</code> List of lint commands to run on files with their target extensions"},{"location":"reference/settings/#lint-lintcommand","title":"Lint &gt; LintCommand","text":"Field Type Default Description <code>command</code> <code>array[string]</code> - Command and arguments to execute for linting (e.g., ['ruff', 'check', '--fix']). Use {file} placeholder to specify where the file path should be inserted, otherwise it will be appended to the end. <code>languages</code> <code>array[string]</code> - List of language names this command handles (e.g., ['python', 'php']). Empty list means all files."},{"location":"reference/settings/#llm","title":"Llm","text":"Field Type Default Description"},{"location":"reference/settings/#llm-main-model","title":"Llm &gt; Main Model","text":"Field Type Default Description <code>model</code> <code>string</code> - The model identifier to use <code>extra_params</code> <code>object</code> - Additional parameters to pass to the model initialization"},{"location":"reference/settings/#llm-weak-model","title":"Llm &gt; Weak Model","text":"Field Type Default Description <code>model</code> <code>string</code> - The model identifier to use <code>extra_params</code> <code>object</code> - Additional parameters to pass to the model initialization"},{"location":"reference/settings/#llm-providers","title":"Llm &gt; Providers","text":"Field Type Default Description <code>gemini</code> <code>LLMProviderConfig</code> <code>{'enable': False, 'extra_params': {}}</code> <code>anthropic</code> <code>LLMProviderConfig</code> <code>{'enable': False, 'extra_params': {}}</code> <code>openai</code> <code>LLMProviderConfig</code> <code>{'enable': False, 'extra_params': {}}</code>"},{"location":"reference/settings/#lsp","title":"Lsp","text":"Field Type Default Description <code>enable</code> <code>boolean</code> <code>false</code> Enable or disable LSP functionality <code>timeout</code> <code>integer</code> <code>30</code> Timeout in seconds for LSP requests <code>servers</code> <code>object</code> - Map of server names to their configurations"},{"location":"reference/settings/#presets","title":"Presets","text":"Field Type Default Description <code>id</code> <code>string</code> - Unique identifier for the preset, used in /preset  command <code>read_only_files</code> <code>array[string]</code> - Files to add to read-only context <code>editable_files</code> <code>array[string]</code> - Files to add to editable context <code>conventions</code> <code>array[string]</code> - Convention files to load <code>prompt</code> <code>string | null</code> - Preset prompt to load into chat input <code>load_on_boot</code> <code>boolean</code> <code>false</code> Automatically load this preset when byte starts"},{"location":"reference/settings/#web","title":"Web","text":"Field Type Default Description <code>enable</code> <code>boolean</code> <code>false</code> Enable web commands <code>chrome_binary_location</code> <code>string</code> <code>/usr/bin/google-chrome</code> Path to Chrome/Chromium binary executable for headless browser automation"}]}