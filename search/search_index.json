{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Byte","text":"<p>A human-in-the-loop AI coding agent that keeps you in control.</p>"},{"location":"#what-is-byte","title":"What is Byte?","text":"<p>Byte is a CLI coding agent designed for developers who want AI assistance without sacrificing control. Unlike autonomous agents that make multiple decisions and tool calls independently, Byte requires your approval for every decision.</p> <p>Key Features:</p> <ul> <li>Review and confirm every change before it's applied</li> <li>See exactly what the agent modifies in your code</li> <li>Manage precisely what information the AI receives</li> <li>Slots into your existing development environment</li> <li>Structured prompts that adapt and evolve with each interaction</li> <li>Automatic linting, formatting, and testing without extra commands</li> </ul>"},{"location":"#design-philosophy","title":"Design Philosophy","text":"<p>Transparency First - You see the complete prompt, not just your input. All interactions are logged for reference and debugging.</p> <p>Explicit Over Implicit - Changes require approval. Context additions need confirmation. No surprises.</p> <p>Complementary, Not Replacement - Byte enhances your workflow without replacing your tools or editor.</p> <p>Quality Over Quantity - Better prompts produce better results. Byte prioritizes well-structured instructions over large context windows.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Get started in three steps:</p> <pre><code># Install with uv\n$ uv tool install byte\n\n# Navigate to your project\n$ cd /path/to/your/project\n\n# Run Byte\n$ byte\n</code></pre> <p>See the Installation Guide for other installation methods including pip and Nix.</p>"},{"location":"#why-this-approach","title":"Why This Approach?","text":""},{"location":"#human-in-the-loop-design","title":"Human-in-the-Loop Design","text":"<p>Every decision and code change requires your confirmation. If you prefer agents that work autonomously, Byte isn't for you. If you value control and transparency, you'll appreciate the deliberate confirmation flow.</p>"},{"location":"#built-for-experienced-developers","title":"Built for Experienced Developers","text":"<p>Designed for experienced developers who understand good design principles. This isn't a tool where you provide a specification and it builds the entire feature. Instead, Byte excels at small, incremental changes that keep you in control. Understanding when to refactor, how to structure code, and what constitutes good design remains your responsibility.</p>"},{"location":"#searchreplace-over-tools","title":"Search/Replace Over Tools","text":"<p>Instead of giving the AI arbitrary tools, explicit Search/Replace blocks show you the exact changes before they happen, making it easy to cancel or modify the proposed work.</p>"},{"location":"#workflow-preservation","title":"Workflow Preservation","text":"<p>Your editor stays central to development. Whether you use Vim, VS Code, or Jetbrains, Byte complements your existing workflow as something you invoke when needed.</p>"},{"location":"#context-management","title":"Context Management","text":"<p>You control exactly what context the LLM receives:</p> <ul> <li>Add or remove files from the active context</li> <li>Monitor token usage and memory consumption</li> <li>Prevent context overflow with targeted information</li> </ul>"},{"location":"#intelligent-prompting","title":"Intelligent Prompting","text":"<p>Structured prompts adapt with each turn:</p> <ul> <li>Previous Search/Replace blocks get removed to maintain focus</li> <li>Instructions follow clear markdown formatting</li> <li>Reduces \"tunnel vision\" where agents fixate on minor issues</li> <li>Full prompt visibility through logging for debugging</li> </ul>"},{"location":"#integrated-tooling","title":"Integrated Tooling","text":"<p>Linting, formatting, and testing run automatically after code changes are applied. Configure your tools once and they work seamlessly in the background without requiring agent interaction.</p>"},{"location":"#controlled-mcp-integration","title":"Controlled MCP Integration","text":"<p>Model Context Protocol (MCP) tools are available but tightly controlled. Manually run tools or restrict which agents can access specific capabilities.</p>"},{"location":"#built-with","title":"Built With","text":"<p>Byte leverages modern Python tooling and AI frameworks:</p> <ul> <li>uv - Fast Python package management</li> <li>LangChain - AI framework for language models</li> <li>LangGraph - Graph-based agent workflows</li> <li>Rich - Beautiful terminal output</li> <li>Prompt Toolkit - Interactive command-line interfaces</li> <li>Catppuccin - Soothing pastel theme</li> </ul>"},{"location":"#inspiration","title":"Inspiration","text":"<p>Byte draws inspiration from excellent projects in the coding agent space:</p> <ul> <li>Aider - The pioneering CLI coding agent that proved the concept</li> <li>Charm's Crush - Elegant terminal agent</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to try Byte? Follow these guides:</p> <ul> <li>Installation - Set up Byte on your system</li> <li>Getting Started - Configure and run your first session</li> <li>Settings - Customize Byte's behavior</li> </ul>"},{"location":"concepts/","title":"Concepts","text":"<p>Byte's design revolves around key principles that work together to provide a powerful yet safe environment for AI-assisted development:</p> <ul> <li>Memory &amp; Context Management - Understanding token usage, context limits, and session management</li> <li>File Context - Control which files the AI can see and modify</li> <li>File Watching - Automatic detection of external file changes</li> <li>Conventions - Project-specific coding standards and style guides</li> <li>Linting - Automated code quality checks and fixes</li> <li>Commit - AI-powered commit message generation</li> <li>Web - Scrape webpages and convert to markdown for LLM context</li> </ul> <p>Read on to explore these concepts in depth, or jump ahead to:</p> <ul> <li>Use the reference documentation to configure Byte for your project</li> </ul>"},{"location":"concepts/commit/","title":"Commit","text":"<p>Byte's commit system uses AI to generate meaningful commit messages by analyzing your staged changes. It automates the entire commit workflow - staging files, running linters, generating commit messages, and handling git operations.</p> <p></p>"},{"location":"concepts/commit/#quick-start","title":"Quick Start","text":"<p>Create an commit:</p> <pre><code>&gt; /commit\n</code></pre> <p>Byte will:</p> <ol> <li>Stage all changed files (with confirmation)</li> <li>Run configured linters on changed files</li> <li>Analyze the git diff with AI</li> <li>Generate a descriptive commit message</li> <li>Create the commit with the generated message</li> </ol> <p>If the commit fails (for example, when pre-commit hooks modify files), Byte will:</p> <ul> <li>Display the error message</li> <li>Prompt you to stage the changes and try again</li> <li>Re-stage all changes if you confirm</li> <li>Retry the commit with the same message</li> </ul> <p>This is common with pre-commit hooks that automatically format or modify files - the hooks run, change the files, and cause the commit to fail because the staging area no longer matches the working directory.</p>"},{"location":"concepts/commit/#configuration","title":"Configuration","text":""},{"location":"concepts/commit/#linting-integration","title":"Linting Integration","text":"<p>Control linting behavior via <code>.byte/config.yaml</code>:</p> <pre><code>lint:\n  enable: true # Disable to skip linting during commits\n  commands:\n    - command: \"ruff format\"\n      extensions: [\".py\"]\n</code></pre> <p>See Linting concept for detailed configuration.</p>"},{"location":"concepts/commit/#commit-message-format","title":"Commit Message Format","text":"<p>The AI generates messages following conventional commit conventions:</p>"},{"location":"concepts/commit/#structure","title":"Structure","text":"<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\n&lt;body&gt;\n\n&lt;footer&gt;\n</code></pre>"},{"location":"concepts/commit/#types","title":"Types","text":"<p>Common commit types the AI uses:</p> <ul> <li>feat - New feature</li> <li>fix - Bug fix</li> <li>docs - Documentation changes</li> <li>style - Code style changes (formatting, whitespace)</li> <li>refactor - Code restructuring without behavior change</li> <li>perf - Performance improvements</li> <li>test - Test additions or modifications</li> <li>chore - Build process, tooling, dependencies</li> </ul>"},{"location":"concepts/commit/#examples","title":"Examples","text":"<p>Simple feature:</p> <pre><code>feat: add password reset functionality\n</code></pre> <p>Bug fix with scope:</p> <pre><code>fix(auth): prevent token expiration race condition\n</code></pre> <p>Breaking change:</p> <pre><code>feat!: redesign authentication API\n\nBREAKING CHANGE: AuthService.login() now returns a Promise\ninstead of synchronous result. Update all callers to use await.\n</code></pre>"},{"location":"concepts/conventions/","title":"Conventions","text":"<p>Conventions are Markdown files stored in <code>.byte/conventions/</code> that describe how code should be written in your project. The AI automatically receives these conventions before generating any code, ensuring consistency across all suggestions and modifications.</p> <p></p>"},{"location":"concepts/conventions/#creating-conventions","title":"Creating Conventions","text":""},{"location":"concepts/conventions/#convention-files","title":"Convention Files","text":"<p>Store convention documents as Markdown files in <code>.byte/conventions/</code>:</p>"},{"location":"concepts/conventions/#file-format","title":"File Format","text":"<p>Conventions use standard Markdown formatting:</p> <pre><code># Python Style Guide\n\n## General Rules\n\n- Use snake_case for functions and variables\n- Use PascalCase for class names\n- Maximum line length: 88 characters\n\n## Documentation\n\nAll public functions require docstrings with usage examples.\n</code></pre>"},{"location":"concepts/conventions/#how-conventions-work","title":"How Conventions Work","text":""},{"location":"concepts/conventions/#automatic-loading","title":"Automatic Loading","text":"<p>When Byte starts, it:</p> <ol> <li>Scans <code>.byte/conventions/</code> for all <code>.md</code> files</li> <li>Loads each file's content</li> <li>Formats them with metadata (filename and source path)</li> <li>Stores them in memory for quick access</li> </ol>"},{"location":"concepts/conventions/#injection-into-prompts","title":"Injection into Prompts","text":"<p>Before each AI interaction, Byte injects all conventions into the prompt:</p> <pre><code># Coding and Project Conventions\n**Important:** Adhere to the following project-specific conventions.\n\n---\ntitle: Python_Style.md\nsource: .byte/conventions/python_style.md\n---\n\n[convention content]\n\n---\ntitle: Api_Design.md\nsource: .byte/conventions/api_design.md\n---\n\n[convention content]\n</code></pre> <p>This ensures the AI always has context about your project's standards.</p>"},{"location":"concepts/conventions/#best-practices","title":"Best Practices","text":""},{"location":"concepts/conventions/#be-specific","title":"Be Specific","text":"<p>Provide concrete examples rather than abstract rules:</p> <p>Less effective:</p> <pre><code>Use good naming conventions.\n</code></pre> <p>More effective:</p> <pre><code>Use descriptive names:\n\n- `user_repository` not `ur`\n- `calculate_total_price()` not `calc()`\n</code></pre>"},{"location":"concepts/conventions/#show-code-examples","title":"Show Code Examples","text":"<p>Include actual code snippets demonstrating the pattern:</p> <pre><code>## Error Handling\n\nCatch specific exceptions:\n\n\\`\\`\\`python\ntry:\nresult = await process_file(path)\nexcept FileNotFoundError:\nlogger.error(f\"File not found: {path}\")\nreturn None\n\\`\\`\\`\n</code></pre>"},{"location":"concepts/conventions/#keep-it-current","title":"Keep It Current","text":"<p>Update conventions as your project evolves. Remove outdated rules and add new patterns as you discover them.</p>"},{"location":"concepts/conventions/#organize-by-topic","title":"Organize by Topic","text":"<p>Create separate files for different aspects:</p> <ul> <li><code>PYTHON_STYLE.MD</code> - Language-specific formatting</li> <li><code>ARCHITECTURE.MD</code> - System design patterns</li> <li><code>API_DESIGN.MD</code> - API conventions</li> <li><code>TESTING.MD</code> - Test organization and patterns</li> </ul>"},{"location":"concepts/file-context/","title":"File Context","text":"<p>The file context acts as the AI's \"workspace\" - only files added to the context are visible to the AI. This design gives you precise control over what the AI can access and change, preventing unwanted modifications and reducing noise in the AI's decision-making.</p> <p></p>"},{"location":"concepts/file-context/#file-modes","title":"File Modes","text":"<p>Byte supports two access modes for files in context:</p>"},{"location":"concepts/file-context/#read-only-mode","title":"Read-Only Mode","text":"<p>Files added as read-only are visible to the AI for reference but cannot be modified. The main use case is to add files you want the AI to be aware of but not change.</p> <p>Command: <code>/read-only &lt;file_path&gt;</code></p> <pre><code>&gt; /read-only config.yaml\nAdded config.yaml (read-only)\n</code></pre>"},{"location":"concepts/file-context/#editable-mode","title":"Editable Mode","text":"<p>Files added as editable can be modified by the AI through SEARCH/REPLACE blocks.</p> <p>Command: <code>/add &lt;file_path&gt;</code></p> <pre><code>&gt; /add src/main.py\nAdded src/main.py (editable)\n</code></pre>"},{"location":"concepts/file-context/#adding-files","title":"Adding Files","text":""},{"location":"concepts/file-context/#single-files","title":"Single Files","text":"<p>Add individual files by specifying their path relative to the project root:</p> <pre><code>&gt; /add src/services/auth.py\n&gt; /read-only README.md\n</code></pre>"},{"location":"concepts/file-context/#multiple-files-with-wildcards","title":"Multiple Files with Wildcards","text":"<p>Use glob patterns to add multiple files at once:</p> <pre><code>&gt; /add src/models/*.py\nAdded src/models/user.py (editable)\nAdded src/models/post.py (editable)\nAdded src/models/comment.py (editable)\n</code></pre> <p>Supported patterns:</p> <ul> <li><code>*</code> - matches any characters in a filename</li> <li><code>**</code> - matches directories recursively</li> <li><code>?</code> - matches a single character</li> <li><code>[seq]</code> - matches any character in seq</li> </ul> <p>Examples:</p> <pre><code>&gt; /add tests/**/*.py           # All Python test files\n&gt; /add src/domain/*/config.py  # All config.py in domain subdirectories\n&gt; /read-only docs/*.md          # All Markdown files in docs\n</code></pre>"},{"location":"concepts/file-context/#viewing-context","title":"Viewing Context","text":""},{"location":"concepts/file-context/#list-all-files","title":"List All Files","text":"<p>See all files currently in context:</p> <pre><code>&gt; /ls\n</code></pre> <p>This displays two panels:</p> <ul> <li>Read-Only Files - Files available for reference</li> <li>Editable Files - Files the AI can modify</li> </ul>"},{"location":"concepts/file-context/#before-each-prompt","title":"Before Each Prompt","text":"<p>Byte automatically displays the current context before accepting your input, so you always know what files the AI can access.</p>"},{"location":"concepts/file-context/#removing-files","title":"Removing Files","text":""},{"location":"concepts/file-context/#single-files_1","title":"Single Files","text":"<p>Remove a file from context when it's no longer needed:</p> <pre><code>&gt; /drop old_file.py\nRemoved old_file.py from context\n</code></pre>"},{"location":"concepts/file-context/#multiple-files-with-wildcards_1","title":"Multiple Files with Wildcards","text":"<p>Remove multiple files using patterns:</p> <pre><code>&gt; /drop tests/**/*.py\n</code></pre> <p>This removes all Python test files from the context.</p>"},{"location":"concepts/file-context/#file-discovery","title":"File Discovery","text":"<p>Byte automatically discovers all files in your project on startup, respecting <code>.gitignore</code> patterns. This enables:</p> <ul> <li>Tab completion - Press Tab while typing file paths to see suggestions</li> <li>Fast lookups - File operations use a cached index for performance</li> <li>Automatic filtering - Git-ignored files are excluded from suggestions</li> </ul> <p>The discovery service:</p> <ol> <li>Scans your project directory recursively</li> <li>Loads <code>.gitignore</code> patterns and configuration ignore rules</li> <li>Builds an in-memory index of available files</li> <li>Updates the index when files change (if file watching is enabled)</li> </ol>"},{"location":"concepts/file-context/#ignore-patterns","title":"Ignore Patterns","text":"<p>Files are automatically excluded based on:</p> <ol> <li><code>.gitignore</code> rules - Standard git ignore patterns from your project's <code>.gitignore</code> file</li> <li>Configuration patterns - Custom ignore rules defined in <code>.byte/config.yaml</code></li> </ol> <p>You can add additional ignore patterns in your <code>.byte/config.yaml</code>:</p> <pre><code>files:\n  ignore:\n    - .byte/cache\n    - .ruff_cache\n    - \"*.log\"\n    - build/\n</code></pre> <p>These patterns use gitignore-style syntax and are combined with your <code>.gitignore</code> rules. Patterns support:</p> <ul> <li><code>*</code> - Wildcard for any characters</li> <li><code>**</code> - Matches directories recursively</li> <li><code>?</code> - Single character match</li> <li>Negation with <code>!</code> prefix</li> <li>Directory-specific patterns with trailing <code>/</code></li> </ul> <p>See the Settings Reference for complete configuration options.</p>"},{"location":"concepts/file-context/#best-practices","title":"Best Practices","text":""},{"location":"concepts/file-context/#start-small","title":"Start Small","text":"<p>Begin with only the files directly related to your task:</p> <pre><code>&gt; /add src/main.py\n&gt; /read-only config.yaml\n</code></pre> <p>Add more files as needed rather than loading everything upfront.</p>"},{"location":"concepts/file-context/#use-read-only-strategically","title":"Use Read-Only Strategically","text":"<p>Add reference files as read-only to provide context without risking unwanted changes:</p> <pre><code>&gt; /read-only docs/architecture.md\n&gt; /read-only .env.example\n</code></pre>"},{"location":"concepts/file-context/#context-in-ai-prompts","title":"Context in AI Prompts","text":"<p>When the AI receives your message, Byte includes a structured context block with all files:</p> <pre><code># Here are the files in the current context:\n\n## READ-ONLY FILES (for reference only):\n---\nsource: config.yaml\nmode: read-only\n---\n[file contents]\n\n## EDITABLE FILES (can be modified):\n---\nsource: src/main.py\nmode: editable\n---\n[file contents]\n</code></pre> <p>This format helps the AI understand:</p> <ul> <li>What files are available</li> <li>What permissions it has for each file</li> <li>The current state of each file</li> </ul>"},{"location":"concepts/file-context/#related-concepts","title":"Related Concepts","text":"<ul> <li>File Watching - Automatic context updates when files change</li> <li>Conventions - Project-specific guidelines automatically included in context</li> <li>Settings Reference - Configuration options for file handling</li> </ul>"},{"location":"concepts/file-watching/","title":"File Watching &amp; AI Comments","text":"<p>Byte automatically watches files in your project for changes. When it detects special AI comment markers, it can automatically add files to context and trigger actions.</p>"},{"location":"concepts/file-watching/#ai-comment-markers","title":"AI Comment Markers","text":"<p>Byte recognizes four types of AI comment markers, each triggering different behavior:</p>"},{"location":"concepts/file-watching/#editable-marker-ai","title":"Editable marker (<code>AI:</code>)","text":"<p>Used for standard code modification requests. Files are added to context as editable, allowing the AI to propose SEARCH/REPLACE blocks.</p> <p>Marker Quick Reference:</p> <p>AI: - Request code modifications (editable mode) AI @ - Provide reference context (read-only mode) AI ? - Ask questions about code (read-only mode, no changes) AI ! - Mark urgent/critical issues (editable mode, highest priority) Read-only marker (AI@)</p> <p>Used to provide reference context without allowing modifications. Files are added as read-only.</p>"},{"location":"concepts/file-watching/#ai-reference-this-pattern-for-other-implementations","title":"AI@ Reference this pattern for other implementations","text":"<p>class BaseHandler: def handle(self): pass</p> <p>Behavior:</p> <p>\u2022 File added to context in read-only mode \u2022 AI can reference the code but cannot propose changes \u2022 Useful for providing examples or patterns to follow</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Question marker (AI?)</p> <p>Used to ask questions about code. The AI provides answers and recommendations without making changes.</p> <p>Before (problematic code):</p>"},{"location":"concepts/file-watching/#ai-should-this-use-a-context-manager-instead","title":"AI? Should this use a context manager instead?","text":"<p>file = open(\"data.txt\") data = file.read() file.close()</p> <p>Behavior:</p> <p>\u2022 File added to context in read-only mode \u2022 AI analyzes the code and provides recommendations \u2022 No code changes are proposed \u2022 Response includes best practices and alternatives</p> <p>Example AI Response:</p> <p>Yes, this should definitely use a context manager. The current code has several issues:</p> <ol> <li>If an exception occurs between open() and close(), the file remains open</li> <li>Manual resource management is error-prone</li> <li>Not following Python best practices</li> </ol> <p>Recommended approach:</p> <pre><code># Improved version using context manager\nwith open(\"data.txt\") as file:\n    data = file.read()\n# File automatically closed when exiting the with block\n\n\nBenefits:\n\n \u2022 Automatic cleanup even if exceptions occur\n \u2022 More Pythonic and readable\n \u2022 Follows RAII pattern and prevents resource leaks\n\n\n\n---\n\n### Urgent task marker (`AI!`)\n\nUsed for critical issues requiring immediate attention. Takes priority over other markers.\n\n```python\n# AI! Fix this security vulnerability immediately\npassword = request.args.get('password')  # Plain text password in GET request!\n\n\nBehavior:\n\n \u2022 File added to context in editable mode\n \u2022 Takes highest priority if multiple AI comments exist\n \u2022 AI proposes immediate fixes using SEARCH/REPLACE blocks\n \u2022 Clear indication this is a critical issue\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nHow It Works\n\nDetection Flow\n\n 1 File change detected: Byte's watcher service detects when you save a file\n 2 AI comment scan: File content is scanned for AI:, AI@, AI?, or AI! markers\n 3 Auto-add to context: File is automatically added with appropriate mode:\n    \u2022 AI: or AI! \u2192 Editable mode\n    \u2022 AI@ or AI? \u2192 Read-only mode\n 4 Prompt interruption: Current prompt is interrupted to process the AI comment\n 5 AI response: AI processes the comment based on marker type:\n    \u2022 : or ! \u2192 Proposes code changes (CoderAgent)\n    \u2022 ? \u2192 Provides analysis and answers (AskAgent)\n    \u2022 @ \u2192 References the code as context\n\nWorkflow steps:\n\n1. You add an AI comment in your editor\n2. Save the file\n3. Byte automatically:\n   - Detects the AI comment marker\n   - Adds the file to context (editable for `AI:` and `AI!`, read-only for `AI@`)\n   - Interrupts the current prompt\n   - Shows you the AI comment\n   - Asks the AI to implement the requested changes\n4. AI responds with SEARCH/REPLACE blocks showing proposed changes\n5. You review and approve or reject the changes\n6. If approved, changes are applied and linters run automatically (if enabled)\n\n**Multiple comments:**\n\nIf multiple AI comments are detected, they're processed together based on priority:\n\n1. `AI!` (urgent) takes precedence\n2. Then `AI?` (questions)\n3. Then `AI:` (regular tasks)\n</code></pre>"},{"location":"concepts/lint/","title":"Linting","text":"<p>Byte's linting system automatically runs configured code quality tools on your files to identify and fix issues. It integrates seamlessly with your workflow, running linters on changed files or specific contexts with a simple command.</p> <p></p>"},{"location":"concepts/lint/#quick-start","title":"Quick Start","text":"<p>Run linters on all changed files:</p> <pre><code>&gt; /lint\n</code></pre> <p>Byte will:</p> <ol> <li>Stage your current changes with git</li> <li>Identify files modified since last commit</li> <li>Run configured linters based on file extensions</li> <li>Display results with error details</li> <li>Optionally attempt AI-assisted fixes for errors</li> </ol>"},{"location":"concepts/lint/#configuration","title":"Configuration","text":"<p>Configure linters in <code>.byte/config.yaml</code>:</p> <pre><code>lint:\n  enable: true\n  commands:\n    - command: \"uv run ruff format --force-exclude --respect-gitignore\"\n      extensions: [\".py\"]\n    - command: \"uv run ruff check --fix --force-exclude\"\n      extensions: [\".py\"]\n    - command: \"prettier --write\"\n      extensions: [\".md\"]\n    - command: \"keep-sorted\"\n      extensions: [\"*\"]\n</code></pre>"},{"location":"concepts/lint/#configuration-options","title":"Configuration Options","text":"<p>For complete configuration details, see the Settings Reference.</p> <p><code>lint.enable</code> (boolean, default: <code>true</code>)</p> <ul> <li>Enable or disable the linting functionality entirely</li> </ul> <p><code>lint.commands</code> (array)</p> <ul> <li>List of lint commands to execute</li> </ul> <p>Each command object has:</p> <p><code>command</code> (string, required)</p> <ul> <li>The shell command to execute (e.g., <code>\"ruff check --fix\"</code>)</li> <li>Command runs from project root directory</li> <li>Use full paths or ensure tools are in PATH</li> </ul> <p><code>extensions</code> (array of strings, required)</p> <ul> <li>File extensions this command applies to (e.g., <code>[\".py\", \".pyi\"]</code>)</li> <li>Use <code>[\"*\"]</code> to run on all files regardless of extension</li> <li>Match is done on file suffix</li> </ul>"},{"location":"concepts/lint/#how-it-works","title":"How It Works","text":"<p>For each lint command:</p> <ol> <li>Filter Files - Select files matching the command's extensions</li> <li>Build Commands - Construct full command: <code>{command} {file_path}</code></li> <li>Execute Async - Run commands concurrently for performance</li> <li>Capture Output - Collect stdout, stderr, and exit codes</li> <li>Report Results - Display summary with errors and warnings</li> </ol>"},{"location":"concepts/lint/#ai-assisted-fixes","title":"AI-Assisted Fixes","text":"<p>When lint errors are found, Byte can attempt automated fixes:</p> <pre><code>Attempt to fix lint errors? (y/N):\n</code></pre> <p>If you confirm:</p> <ol> <li>Coder Agent - Byte invokes the coder agent for each file</li> <li>Error Context - Provides the lint error message and file path</li> <li>Suggested Fix - AI proposes SEARCH/REPLACE blocks to resolve the issue</li> <li>Review - You review and approve the changes</li> </ol> <p>This is particularly useful for:</p> <ul> <li>Formatting issues the linter couldn't auto-fix</li> <li>Complex refactoring suggested by linters</li> <li>Understanding why a lint rule failed</li> </ul>"},{"location":"concepts/lint/#order-matters","title":"Order Matters","text":"<p>Run formatters before linters:</p> <pre><code>commands:\n  - command: \"ruff format\" # Format first\n    extensions: [\".py\"]\n  - command: \"ruff check --fix\" # Then check\n    extensions: [\".py\"]\n</code></pre> <p>This prevents formatters from introducing new lint errors.</p>"},{"location":"concepts/lint/#keep-commands-fast","title":"Keep Commands Fast","text":"<p>Use caching and incremental modes:</p> <pre><code>- command: \"mypy --cache-dir=.mypy_cache\"\n  extensions: [\".py\"]\n</code></pre>"},{"location":"concepts/memory/","title":"Memory &amp; Context Management","text":"<p>Byte's approach to memory and context is designed to keep conversations focused, reduce token usage, and encourage best practices through deliberate constraints. Understanding how Byte manages context helps you work more effectively with the AI.</p> <p></p>"},{"location":"concepts/memory/#analytics-context-tracking","title":"Analytics &amp; Context Tracking","text":"<p>Byte displays an analytics bar after each AI interaction, providing real-time feedback about token usage and context consumption. The bar features statistics about the current session but also includes a progress bar showing you how much of the agent's input context has been used.</p> <p>This visual indicator helps you manage input context effectively - you can see at a glance when you're approaching context limits and should consider removing files that are no longer being used.</p> <p>The analytics panel shows:</p> <ul> <li>Memory usage progress bar - Visual representation of context consumption</li> <li>Token statistics - Sent and received tokens for the last message</li> <li>Cost tracking - Per-message and session-total costs</li> </ul>"},{"location":"concepts/memory/#no-persistent-memory","title":"No Persistent Memory","text":"<p>Byte does not persist conversation history between sessions. When you exit and restart Byte, the AI starts fresh with no memory of previous conversations.</p>"},{"location":"concepts/memory/#why-no-persistence","title":"Why No Persistence?","text":"<p>This design choice serves several purposes:</p> <p>Keeps You Honest</p> <ul> <li>Forces clear, explicit communication in each session</li> <li>Prevents relying on unstated context from previous conversations</li> <li>Encourages complete problem descriptions</li> </ul> <p>Reduces Context Size</p> <ul> <li>No accumulation of stale conversation history</li> <li>Lower token costs per interaction</li> <li>Faster response times</li> </ul> <p>Encourages Documentation</p> <ul> <li>Important patterns belong in Conventions, not chat history</li> <li>Knowledge becomes project documentation, not hidden in logs</li> <li>Team members benefit from documented standards</li> </ul>"},{"location":"concepts/memory/#when-to-create-conventions","title":"When to Create Conventions","text":"<p>If the AI consistently follows a pattern or standard you've explained:</p> <pre><code>&gt; The AI keeps suggesting async/await patterns for our services\n\n\u2713 Create a convention file documenting your async patterns\n\u2717 Don't rely on explaining it in every session\n</code></pre> <p>Add it to <code>.byte/conventions/</code>:</p> <pre><code># Async Patterns\n\nAll service methods must be async:\n\n\\`\\`\\`python\nclass MyService(Service):\nasync def process(self) -&gt; bool:\nresult = await self.operation()\nreturn result\n\\`\\`\\`\n</code></pre> <p>Now the AI knows this rule in every session without you repeating it.</p>"},{"location":"concepts/memory/#smart-block-removal","title":"Smart Block Removal","text":"<p>To keep the AI focused on current code state and reduce input context, Byte removes SEARCH/REPLACE blocks from historic messages after they're processed.</p>"},{"location":"concepts/memory/#how-it-works","title":"How It Works","text":"<p>After the AI generates SEARCH/REPLACE blocks:</p> <ol> <li>Blocks are applied to your files (with your approval)</li> <li>Historic messages are masked - blocks are replaced with summaries</li> <li>Fresh file content is provided from the file context</li> <li>AI sees current state - not outdated proposed changes</li> </ol>"},{"location":"concepts/memory/#example-transformation","title":"Example Transformation","text":"<p>Original AI Message:</p> <pre><code>Here's how to fix that:\n\n'''python\n+++++++ src/main.py\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; SEARCH\ndef old_function():\npass\n=======\ndef new_function():\nreturn True\n\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; REPLACE\n&gt; &gt; &gt; &gt; &gt; &gt; &gt; '''\n\nThis change updates the function to return a boolean.\n</code></pre> <p>After Processing (in chat history):</p> <pre><code>Here's how to fix that:\n\n'''python\n_[Changes applied to `src/main.py` - search/replace block removed]_\n'''\n\nThis change updates the function to return a boolean.\n</code></pre>"},{"location":"concepts/memory/#why-remove-blocks","title":"Why Remove Blocks?","text":"<p>Prevents Confusion</p> <ul> <li>If you corrected the AI's code after applying blocks, the old suggestions disappear</li> <li>The AI only sees what's actually in the files now</li> <li>No conflicting versions of code in context</li> </ul> <p>Saves Tokens</p> <ul> <li>SEARCH/REPLACE blocks are verbose</li> <li>Historic blocks consume input context without adding value</li> <li>More tokens available for relevant information</li> </ul> <p>Keeps AI On Task</p> <ul> <li>Focus on current problem, not past solutions</li> <li>Fresh perspective on each turn</li> <li>Reduces tendency to repeat previous patterns</li> </ul>"},{"location":"concepts/web/","title":"Web","text":"<p>Byte's web command allows you to scrape web pages and convert them to markdown format for use in your AI conversations. It uses headless Chrome to fetch pages, handles JavaScript-rendered content, and converts HTML to clean markdown that can be added to the LLM context.</p> <p></p>"},{"location":"concepts/web/#quick-start","title":"Quick Start","text":"<p>Scrape a webpage:</p> <pre><code>&gt; /web https://example.com\n</code></pre> <p>Byte will:</p> <ol> <li>Launch headless Chrome browser</li> <li>Navigate to the URL and wait for JavaScript to render</li> <li>Extract the page content</li> <li>Convert HTML to markdown format</li> <li>Display the formatted content</li> <li>Prompt you to add it to the LLM context</li> </ol>"},{"location":"concepts/web/#configuration","title":"Configuration","text":"<p>Configure web functionality in <code>.byte/config.yaml</code>:</p> <pre><code>web:\n  enable: true\n  chrome_binary_location: /usr/bin/google-chrome\n</code></pre> <p>For complete configuration details, see the Settings Reference.</p>"},{"location":"concepts/web/#context-integration","title":"Context Integration","text":"<p>After displaying the content, you have three options:</p> <p></p>"},{"location":"concepts/web/#yes","title":"Yes","text":"<p>Add raw markdown directly to context</p> <p>The content is stored with a key derived from the URL slug for easy reference.</p>"},{"location":"concepts/web/#clean-with-llm","title":"Clean with LLM","text":"<p>Use AI to extract relevant information</p> <p>The cleaner agent:</p> <ul> <li>Removes navigation, footers, and boilerplate</li> <li>Extracts main content and key points</li> <li>Formats it for optimal LLM comprehension</li> <li>Adds cleaned version to context</li> </ul>"},{"location":"concepts/web/#no","title":"No","text":"<p>Discard the content</p> <p>The scraped content is not added to the context.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>To help you get started with Byte, we'll cover a few important topics:</p> <ul> <li>Installing Byte</li> <li>First steps after installation</li> </ul> <p>Read on, or jump ahead to another section:</p> <ul> <li>Learn more about the core concepts in Byte</li> </ul>"},{"location":"getting-started/first-steps/","title":"First Steps","text":"<p>Configure Byte and run your first session.</p>"},{"location":"getting-started/first-steps/#prerequisites","title":"Prerequisites","text":"<p>Before running Byte:</p> <ul> <li>Git repository - Byte operates inside a git repository</li> <li>Good terminal - A modern terminal emulator with proper rendering support (like Kitty, Foot, WezTerm, or Alacritty)</li> <li>API key - One of these environment variables must be set:</li> <li><code>ANTHROPIC_API_KEY</code> for Claude models</li> <li><code>GEMINI_API_KEY</code> for Google Gemini</li> <li><code>OPENAI_API_KEY</code> for OpenAI models</li> </ul>"},{"location":"getting-started/first-steps/#configuration","title":"Configuration","text":""},{"location":"getting-started/first-steps/#set-your-api-key","title":"Set Your API Key","text":"<p>Export the environment variable for your chosen provider:</p> <pre><code>$ export ANTHROPIC_API_KEY=your-key-here\n</code></pre> <p>Or create a <code>.env</code> file in your project root:</p> <pre><code>$ echo \"ANTHROPIC_API_KEY=your-key-here\" &gt; .env\n</code></pre>"},{"location":"getting-started/first-steps/#navigate-to-your-project","title":"Navigate to Your Project","text":"<p>Byte runs from within a git repository:</p> <pre><code>$ cd /path/to/your/project\n$ git init  # If not already a git repo\n</code></pre>"},{"location":"getting-started/first-steps/#running-byte","title":"Running Byte","text":"<p>Launch Byte from your project directory:</p> <pre><code>$ byte\n</code></pre> <p>On first run, Byte creates:</p> <ul> <li><code>.byte/</code> directory in your project root</li> <li><code>config.yaml</code> with default configuration</li> <li>Cache and history directories</li> </ul> <p>Tip</p> <p>Add <code>.byte/cache</code> to your <code>.gitignore</code> to exclude temporary files and chat history.</p>"},{"location":"getting-started/first-steps/#the-byte-directory","title":"The .byte Directory","text":"<p>Byte creates a <code>.byte/</code> directory containing:</p> <ul> <li>config.yaml - Configuration settings for model selection, tool availability, and behavior (see Settings Reference)</li> <li>cache/ - Temporary data and performance optimizations</li> <li>conventions/ - Project-specific style guides and coding standards that are automatically included in the AI's context</li> </ul> <p>See the Conventions guide to learn how to define project-specific coding standards that Byte automatically includes in the AI's context.</p>"},{"location":"getting-started/first-steps/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/first-steps/#adding-files-to-context","title":"Adding Files to Context","text":"<p>The AI needs to know about files before suggesting changes:</p> <pre><code>/add src/main.py\n</code></pre> <p></p>"},{"location":"getting-started/first-steps/#making-changes","title":"Making Changes","text":"<p>Ask Byte to modify code:</p> <pre><code>&gt; Refactor the main function to use dependency injection\n</code></pre> <p>Review the proposed changes, then approve or reject them.</p> <p>Learn how to work with files in the AI's context - see File Context for details on adding, viewing, and removing files.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Install Byte using your preferred Python package manager. Once installed, you'll have a <code>byte</code> command available in your terminal.</p>"},{"location":"getting-started/installation/#installing-byte","title":"Installing Byte","text":""},{"location":"getting-started/installation/#using-uv","title":"Using uv","text":"<p>The fastest installation method uses uv, a modern Python package installer:</p> <pre><code>$ curl -LsSf https://astral.sh/uv/install.sh | sh\n$ uv tool install byte-ai-cli\n</code></pre>"},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<p>Install with pip if you prefer traditional Python tooling:</p> <pre><code>$ pip install byte-ai-cli\n</code></pre>"},{"location":"getting-started/installation/#using-nix-flakes","title":"Using Nix Flakes","text":"<p>For NixOS users or those with Nix flakes enabled, add to your configuration:</p> <pre><code>{\n  inputs = {\n    byte.url = \"github:UseTheFork/byte\";\n  };\n}\n</code></pre> <p>Include in your system packages:</p> <pre><code>environment.systemPackages = [\n  inputs.byte.packages.${system}.default\n];\n</code></pre> <p>Or run directly without installation:</p> <pre><code>$ nix run github:UseTheFork/byte\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Confirm the installation succeeded:</p> <p>Tip</p> <p>Before running Byte, you must have at least one of these environment variables set: <code>ANTHROPIC_API_KEY</code>, <code>GEMINI_API_KEY</code>, or <code>OPENAI_API_KEY</code>. See First Steps for configuration details.</p> <pre><code>$ byte\n</code></pre> <p>You should see the following screen after startup.</p> <p></p>"},{"location":"getting-started/workflow-example/","title":"Workflow Example","text":"<p>This guide demonstrates a complete workflow for adding a feature to Byte using domain-driven development practices. You'll learn how to manage context, reference existing patterns, and iterate on changes with the AI.</p> <p>Byte works best when your project uses Domain-Driven Design (DDD) for both frontend and backend. You can feed an entire domain into the read-only context, making it easy to provide the AI with a template to follow.</p> <p>In this example, we'll add a progress display to the web command. This workflow uses the CLI, but it can be done just as easily using file watching and AI commands.</p>"},{"location":"getting-started/workflow-example/#step-1-add-files-to-editable-context","title":"Step 1: Add Files to Editable Context","text":"<p>First, add the files Byte will modify to the editable context. Since the web command resides in the web domain, add the entire domain for editing:</p> <pre><code>/add src/byte/domain/web/**\n</code></pre> <p></p> <p>All files in the web domain are now in the editable context.</p>"},{"location":"getting-started/workflow-example/#step-2-add-reference-files","title":"Step 2: Add Reference Files","text":"<p>Next, add reference files to the read-only context. This can be an entire domain or just a few files. The key is adding them as read-only so the AI can reference them without making changes.</p> <p>In this case, the rune spinner is used in only one file, so add the component and its implementation to the read-only context:</p> <pre><code>/read-only src/byte/domain/cli/rich/rune_spinner.py\n/read-only src/byte/domain/cli/service/stream_rendering_service.py\n</code></pre> <p></p> <p>Now the editable files and read-only reference files are both in context.</p>"},{"location":"getting-started/workflow-example/#step-3-add-external-documentation","title":"Step 3: Add External Documentation","text":"<p>At this point, you could ask the agent to complete the change. However, since the web scraping implementation uses <code>pydoll</code>, it's a good idea to include some of the documentation in the context as well. Use the <code>/web</code> command for this:</p> <pre><code>/web https://pydoll.tech/docs/\n</code></pre> <p></p> <p>Once scraped, Byte asks if you want to add the content as-is, clean it up using the weak model, or cancel. It's usually good practice to clean up scraped content, but since this feature is small, keep it as-is.</p> <p></p> <p>Now that all the pieces are together, ask Byte to make the change.</p>"},{"location":"getting-started/workflow-example/#step-4-request-the-change","title":"Step 4: Request the Change","text":"<p>You can request the change in two different ways:</p> <p>Option A: Use <code>/ask</code> first</p> <p>Use the <code>/ask</code> command to see how Byte recommends making this change. Because <code>ask</code> doesn't have tools or the ability to change files, it's a good way to discuss the change before Byte implements it. This is possible because memory is shared between main agents.</p> <p>Option B: Request directly</p> <p>Don't use any command and ask Byte to make the change directly. This is more of a YOLO move, but you can always press <code>Ctrl+C</code> to cancel generation mid-prompt.</p> <p>For this tutorial, use method A:</p> <pre><code>/ask How would you suggest we implement a rich Live using our Rune spinner while we are scraping web content in our ChromiumService\n</code></pre> <p></p> <p>The recommendation is close but not perfect. Depending on how close the response is, you may want to follow up with another <code>/ask</code>, but in this case, course correct while asking to implement:</p> <pre><code>Instead of calling `self.console = await self.make(ConsoleService)` at boot, call it at the start of `do_scrape`. Also use `with Live(table, refresh_per_second=4) as live:`\n</code></pre> <p></p> <p>Byte uses SEARCH/REPLACE blocks so you can see the changes as they happen.</p> <p>Once the change is applied, if you have lint commands enabled, Byte will run those commands against the changed files:</p> <p></p>"},{"location":"getting-started/workflow-example/#step-5-commit-the-change","title":"Step 5: Commit the Change","text":"<p>That's it! Since the change is complete, run the <code>/commit</code> command to lint the files and commit the change:</p> <pre><code>/commit\n</code></pre> <p></p> <p>You can now choose to keep asking for changes in the same manner, or use the <code>/clear</code> command to clear the chat history, or <code>/reset</code> to clear both history and context.</p> <p>If you continue making changes, remember to keep an eye on how much memory has been used:</p> <p></p>"},{"location":"getting-started/workflow-example/#related-concepts","title":"Related Concepts","text":"<ul> <li>File Context - Managing files in the AI's workspace</li> <li>Commit - AI-powered commit message generation</li> <li>Web - Scraping documentation for context</li> </ul>"},{"location":"reference/","title":"Introduction","text":""},{"location":"reference/commands/","title":"Commands","text":"<p>Byte provides a comprehensive set of commands for interacting with your codebase, managing context, and controlling the AI assistant. Commands are organized by category for easy reference.</p>"},{"location":"reference/commands/#system","title":"System","text":"<p><code>!&lt;command&gt;</code> - Execute a shell command and optionally add output to conversation context</p>"},{"location":"reference/commands/#agent","title":"Agent","text":"<p><code>/ask</code> - Ask the AI agent a question or request assistance</p>"},{"location":"reference/commands/#files","title":"Files","text":"<p><code>/add</code> - Add file to context as editable</p> <p><code>/drop</code> - Remove file from context</p> <p><code>/ls</code> - List all files currently in the AI context</p> <p><code>/read-only</code> - Add file to context as read-only</p>"},{"location":"reference/commands/#general","title":"General","text":"<p><code>/commit</code> - Create an AI-powered git commit with automatic staging and linting</p> <p><code>/copy</code> - Copy code blocks from the last message to clipboard</p> <p><code>/exit</code> - Exit the Byte application gracefully</p> <p><code>/lint</code> - Run configured linters on changed files or current context</p>"},{"location":"reference/commands/#memory","title":"Memory","text":"<p><code>/clear</code> - Clear conversation history and start a new thread</p> <p><code>/reset</code> - Reset conversation history and clear file context completely</p> <p><code>/undo</code> - Undo the last conversation step</p>"},{"location":"reference/commands/#session-context","title":"Session Context","text":"<p><code>/context:drop</code> - Remove item from session context</p> <p><code>/context:ls</code> - List all session context items</p> <p><code>/web</code> - Scrape a webpage and convert it to markdown</p>"},{"location":"reference/settings/","title":"Byte Configuration Settings","text":"<p>Byte's configuration system uses a YAML file located at <code>.byte/config.yaml</code> to control all aspects of the application's behavior. Configuration is organized into logical sections covering CLI behavior, LLM providers, file handling, and feature-specific settings.</p>"},{"location":"reference/settings/#cli","title":"Cli","text":"Field Type Default Description <code>ui_theme</code> <code>mocha, macchiato, latte, frappe</code> <code>mocha</code> Catppuccin theme variant for the CLI interface (mocha/macchiato are dark, latte is light, frappe is cool dark) <code>syntax_theme</code> <code>github-dark, bw, sas, staroffice, xcode, monokai, lightbulb, rrt</code> <code>monokai</code> Pygments theme for code block syntax highlighting in CLI output"},{"location":"reference/settings/#llm","title":"Llm","text":"Field Type Default Description <code>model</code> <code>anthropic, gemini, openai</code> <code>anthropic</code> The LLM provider to use for AI operations"},{"location":"reference/settings/#llm-gemini","title":"Llm &gt; Gemini","text":"Field Type Default Description <code>enabled</code> <code>boolean</code> <code>false</code> Whether this LLM provider is enabled and available for use <code>api_key</code> <code>string</code> - API key for authenticating with the LLM provider <code>model_params</code> <code>object</code> - Additional parameters to pass to the model initialization"},{"location":"reference/settings/#llm-anthropic","title":"Llm &gt; Anthropic","text":"Field Type Default Description <code>enabled</code> <code>boolean</code> <code>false</code> Whether this LLM provider is enabled and available for use <code>api_key</code> <code>string</code> - API key for authenticating with the LLM provider <code>model_params</code> <code>object</code> - Additional parameters to pass to the model initialization"},{"location":"reference/settings/#llm-openai","title":"Llm &gt; Openai","text":"Field Type Default Description <code>enabled</code> <code>boolean</code> <code>false</code> Whether this LLM provider is enabled and available for use <code>api_key</code> <code>string</code> - API key for authenticating with the LLM provider <code>model_params</code> <code>object</code> - Additional parameters to pass to the model initialization"},{"location":"reference/settings/#lint","title":"Lint","text":"Field Type Default Description <code>enable</code> <code>boolean</code> <code>true</code> Enable or disable the linting functionality <code>commands</code> <code>array[LintCommand]</code> <code>[]</code> List of lint commands to run on files with their target extensions"},{"location":"reference/settings/#lint-lintcommand","title":"Lint &gt; LintCommand","text":"Field Type Default Description <code>command</code> <code>string</code> - Shell command to execute for linting (e.g., 'ruff check --fix') <code>extensions</code> <code>array[string]</code> - List of file extensions to run this command on (e.g., ['.py', '.pyi']). Empty list means all files."},{"location":"reference/settings/#files","title":"Files","text":"Field Type Default Description <code>ignore</code> <code>array[string]</code> <code>['.byte/cache', '.ruff_cache', '.idea', '.venv', '.env', '.git', '.pytest_cache', '__pycache__', 'node_modules', 'dist']</code> List of gitignore-style patterns to exclude from file discovery. Patterns support wildcards and are combined with .gitignore rules."},{"location":"reference/settings/#files-watch","title":"Files &gt; Watch","text":"Field Type Default Description <code>enable</code> <code>boolean</code> <code>false</code> Enable file watching for AI comment markers (AI:, AI@, AI?, AI!). When enabled, Byte automatically detects changes and processes AI instructions."},{"location":"reference/settings/#edit_format","title":"Edit_Format","text":"Field Type Default Description <code>enable_shell_commands</code> <code>boolean</code> <code>false</code> Enable execution of shell commands from AI responses. When disabled, shell command blocks will not be executed. <code>mask_message_count</code> <code>integer</code> <code>1</code> Number of recent AI messages to exclude from masking. Messages older than this count will have their SEARCH/REPLACE blocks removed to reduce token usage."},{"location":"reference/settings/#web","title":"Web","text":"Field Type Default Description <code>enable</code> <code>boolean</code> <code>false</code> Enable web commands <code>chrome_binary_location</code> <code>string</code> <code>/usr/bin/google-chrome</code> Path to Chrome/Chromium binary executable for headless browser automation"}]}